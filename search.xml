<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[C++学习笔记（四）]]></title>
      <url>/2017/11/05/CppNotes_4/</url>
      <content type="html"><![CDATA[<p>C++ 字符串 C++ string 标准库</p>
<a id="more"></a>
<p>###命令空间的 <code>using</code>声明</p>
<p>我们常用到的库函数基本上属于命名空间 <code>std</code>，例如：<code>std::cin</code>从标准输入中读取内容。使用作用域操作符 (<code>::</code>)的含义，编译器应该从操作符左侧名字中所示的作用域中寻找右侧那个名字。 因此，<code>std::cin</code>的意思就是使用命名空间 <code>std</code>中的名字 <code>cin</code>.</p>
<p>一种简单的方法可以使用命名空间中的成员，使用 <code>using</code>声明。</p>
<p>使用了 <code>using</code>就无需声明专门的前缀，形如<code>::</code>，也能够使用所需的名字了。</p>
<p>using 声明的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name ;</div></pre></td></tr></table></figure>
<p>一旦声明了上述语句，我们可以直接访问命名空间的名字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i ; </div><div class="line">    <span class="built_in">cin</span> &gt;&gt; i;  正确，<span class="built_in">cin</span> 和 <span class="built_in">std</span>::<span class="built_in">cin</span> 含义相同</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; i; 错误，没有对应的<span class="keyword">using</span>声明，必须使用完整名字</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; 正确，显示的从 <span class="built_in">std</span> 中使用 <span class="built_in">cout</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><p>每个using声明引入命名空间中的一个成员。 可以把要用到的标准库中的名字都以 using 声明的形式表示出来。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</div><div class="line"><span class="keyword">using</span> sed::<span class="built_in">cout</span> ; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"Enter two numbres: "</span>&lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">  	<span class="keyword">int</span> v1,v2;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt;v2;</div><div class="line">  	<span class="built_in">cout</span>&lt;&lt; v1 &lt;&lt;<span class="string">" "</span>&lt;&lt; v2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="头文件不能够包含-using声明"><a href="#头文件不能够包含-using声明" class="headerlink" title="头文件不能够包含 using声明"></a>头文件不能够包含 <code>using</code>声明</h3><p>头文件的代码不应该使用 using 声明，只是因为头文件的内容会copy到所有引用它的文件中去，如果头文件中有某个 using 声明，那么每个使用了该头文件的都会有这个声明。 对于某些程序来收，由于不经意间包含了某些名字，会出现一些问题。</p>
<h2 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 <code>string</code></h2><p>标准库类型 <code>string</code>表示可变长的字符序列，使用<code>string</code>类型必须首先包含<code>string</code>头文件，作为标准库的一部分，<code>string</code>定义在命名空间 <code>std</code>，接下来的实例假定已经包含了下述代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div></pre></td></tr></table></figure>
<h2 id="常用的-string操作"><a href="#常用的-string操作" class="headerlink" title="常用的 string操作"></a>常用的 <code>string</code>操作</h2><h3 id="定义和初始化-string对象"><a href="#定义和初始化-string对象" class="headerlink" title="定义和初始化 string对象"></a>定义和初始化 <code>string</code>对象</h3><p>如何初始化对象是由类本身决定的。 一个类可以定义多种初始化对象的方式，只不过这些方式之间必须有所区别，或者是初始值的数量不同，或者是初始值的类型不同。 </p>
<p>string 初始化的常用方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1 ; 默认的初始化，s1 是一个空字符串</div><div class="line"><span class="built_in">string</span> s2 = s1 ; s2 是 s1的副本</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s1)</span> </span>; s2 是 s1 的副本</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">"value"</span>)</span></span>; s4 是 <span class="string">"value"</span>的副本 </div><div class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>; a2 是该字符串字面值的副本</div><div class="line">string s4(10,'c') s4 的内容是 "cccccccccc"</div></pre></td></tr></table></figure>
<p>通过默认的方式初始化一个 string ,将会得到一个空的 string 也就是说，该 string 对象中没有任何字符</p>
<h3 id="直接初始化-和拷贝初始化"><a href="#直接初始化-和拷贝初始化" class="headerlink" title="直接初始化 和拷贝初始化"></a>直接初始化 和拷贝初始化</h3><p>C++有几种不同的初始化方式，通过 string 我们可以清楚地看到在这些初始化方式，通过 string 的初始化，我们可以看清楚各种不同的初始化方式之间的区别和联系</p>
<ol>
<li>如果使用等号（=）初始化一个变量，实际上执行的拷贝初始化，编译器将等号右边的初始值直接copy到新创建的对象中去。</li>
<li>如果不使用等号，则执行的是直接初始化</li>
</ol>
<p>当初始化值只有一个的时候，使用直接初始化或者copy初始化都行。如果要初始化的值有很多个，一般来说都是用直接初始化的方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>; copy initialization </div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>; 直接初始化</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>; 直接初始化</div></pre></td></tr></table></figure>
<p>对于多个值进行初始化的情况，非要copy初始化的方式 也不是不可以，不过要显示的创建一个临时的对象用于copy</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s8 = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>); copy 初始化，</div></pre></td></tr></table></figure>
<p>这句话本质上可以写成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">temp</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;</div><div class="line"><span class="built_in">string</span> s9 = temp;</div></pre></td></tr></table></figure>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>string对象中的大多数操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">os os&lt;&lt;s 将s写到输出流os中，返回os</div><div class="line">is is&gt;&gt;s 从is中读取字符串赋值给 s,字符串以空白分割，返回is</div><div class="line">bool getline(is,s) s为空返回true,否则返回false</div><div class="line"> s.size() 返回s中字符的对象</div><div class="line"> s[n] 返回s中第n个字符的引用，n 从<span class="number">0</span>记起</div><div class="line"> s1+s2 返回s1和s2连接后的结果</div><div class="line"> s1 = s2 s2的副本代替s1中原来的字符 </div><div class="line"> s1==s2 判断s1和s2中的字符是否完全 一样</div><div class="line"> s1 != s2</div><div class="line"> &lt;,&lt;=,&gt;,&gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感</div></pre></td></tr></table></figure>
<h3 id="读写-string-对象"><a href="#读写-string-对象" class="headerlink" title="读写 string 对象"></a>读写 string 对象</h3><p>可以使用 iostream 来读写int,double 等内置类型的值，同样也可以使用io操作读写string对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">string</span> s;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; s;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读取未知数量的string 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> word;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt;word)</div><div class="line">      <span class="built_in">cout</span>&lt;&lt;word&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-getline-读取一整行"><a href="#使用-getline-读取一整行" class="headerlink" title="使用 getline 读取一整行"></a>使用 getline 读取一整行</h3><p>有时候我们希望在所得到的字符串中保留输入时的空白值，这时应该用 getline()函数代替原来的 &gt;&gt;运算，getline() 的参数是一个输入流和一个string 对象，函数从给定的输入流中读取内容直至遇到换行符位置，然后把所读的内容存入到string对象中去（注意不包括换行符）</p>
<p>和输入运算符一样，getline()也返回它的流参数.因此既然输入运算符能够作为新的条件，我们也能够使用 getline() 运算符的结果作为条件，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     <span class="built_in">string</span> line;</div><div class="line">     <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,line))</div><div class="line">       <span class="built_in">cout</span> &lt;&lt;line &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="string-的-empty和-size操作"><a href="#string-的-empty和-size操作" class="headerlink" title="string 的 empty和 size操作"></a>string 的 empty和 size操作</h3><p>empty 根据string 对象是否为空返回一个对应的布尔值</p>
<p>我们可以改写之前的程序，可以做到只输入非空的行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>,line))</div><div class="line">  <span class="keyword">if</span>(!line.empty())</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; line &lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>size 函数返回string对象的长度（即string对象中字符的个数），可以使用size函数只输出长度超过 80 个字符的行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> line ;</div><div class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,line))</div><div class="line">  <span class="keyword">if</span>(line.size() &gt;<span class="number">80</span>)</div><div class="line">     <span class="built_in">cout</span>&lt;&lt;line &lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>它会从cin中读取输入直到遇到EOF，</p>
<blockquote>
<p>Linux下EOF的输入方式是ctrl+d Windows 下的EOF是 ctrl +Z</p>
</blockquote>
<h3 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h3><p>对于size() 来收，返回一个int或者是一个unsigned 似乎都是合情合理的，但是其实size()返回的是一个 <code>size_type</code>类型的值，</p>
<p>string 类以及其他大多数标准库类型都定义了几种配套的类型，这些配套的类型体现了标准库类型与机器无关的特性，类型 size_type 就是其中的一种，在具体使用的时候，通过作用域可以存放string类的size函数，返回值的变量，都应该是</p>
<p><code>string::size_type</code>的对象，</p>
<p>在C++11中，编译器中通过 auto 或者 decltype 来推断 变量的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> len = line.size() ; <span class="comment">//len 的类型是 string::size_type;</span></div></pre></td></tr></table></figure>
<p>size 函数返回是一个无符号的整数，因此，如果在表达式中混用了带符号的整数和无符号的整数都可能产生 意想不到的结果，例如： n是一个具有负数的int ,则表达式a.size() &lt;n 的结果几乎坑定是true. 这是因为负值会自动的转换成 一个比较大的无符号的值。</p>
<blockquote>
<p>如果一个表示式中已经有了size()函数就不要在使用 int,这样可以避免混用int和unsigned可能带来的问题</p>
</blockquote>
<h3 id="两个string对象相加"><a href="#两个string对象相加" class="headerlink" title="两个string对象相加"></a>两个string对象相加</h3><p>两个string对象相加会得到一个新的string对象，其内容是吧左侧的运算对象和右侧的运算对象串接而成，此外符合赋值运算符（+=）将右侧的string对象的内容追加到 左侧的string对象的后面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1 = <span class="string">"Hello, "</span>, s2 = <span class="string">"world\n"</span>;</div><div class="line"><span class="built_in">string</span> s3 = s1+s2;</div><div class="line">s1+=s2;</div></pre></td></tr></table></figure>
<h3 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h3><p>即使一种类型并非所需，我们也可以使用它，不过前提是这种类型可以自动的转换成所需的类型，标准库允许吧字符字面值，字符串字面值转化成string对象。</p>
<p>需要string对象的地方可以使用这种两种字面值来替代，利用这一点将之前的程序改写为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>, s2 = <span class="string">"world"</span>;</div><div class="line"><span class="built_in">string</span> s3 = s1+<span class="string">", "</span>+ s2 +<span class="string">"\n"</span>;</div></pre></td></tr></table></figure>
<p>当string对象和字符字面值以及字符串字面值混在一条语句中使用时，必须确保每个加法运算（+）两侧的对象至少有一个是string。</p>
<p>注意一定有一个是string对象，而不是 字面值，不能够将字面值直接相加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</div><div class="line"><span class="built_in">string</span> s6 = s1+<span class="string">", "</span>+<span class="string">"world"</span>;<span class="comment">//错误的，字面值不是string,不能够将两个字面值直接相加。 （后一个加法）</span></div><div class="line">应该写成：</div><div class="line"><span class="built_in">string</span> temp = s1 +<span class="string">", "</span>;</div><div class="line"><span class="built_in">string</span> s6 = temp+<span class="string">"world"</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，由于为了和C兼容，C++语言字符串字面值并不是标准库类型string对象，切记，字符串字面值与 string 是不同的类型。</p>
</blockquote>
<h2 id="处理string对象中的字符："><a href="#处理string对象中的字符：" class="headerlink" title="处理string对象中的字符："></a>处理string对象中的字符：</h2><p>我们经常会处理string对象中的字符，比如检查一个string对象是否包含空白，或者把string对象中的字母改成小写，查看特定的字符是否出现等。</p>
<p>这类处理的一个关键问题是如何获取字符本身，有些时候需要处理string对象中的每一个字符，另外一些情况下只需要处理某个特定的字符，这些时候遇到某个条件处理就要停下来。这些操作通常需要处理语言和库的很多方面。‘</p>
<p>另一个关键词问题是要能改变某个字符的特性，在 <code>cctype</code> 头文件中定义了一组标准库函数处理这部分工作，列出了主要的函数名极其定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cctype 头文件中的函数</div><div class="line"><span class="built_in">isalnum</span>(c) 当c是字母或者数字时为真</div><div class="line"><span class="built_in">isalpha</span>(c) 当c是字母是为真</div><div class="line"><span class="built_in">iscntrl</span>(c) 当c是控制字符时为真</div><div class="line"><span class="built_in">isdigit</span>(c) 当c是数字时为真</div><div class="line"><span class="built_in">isgraph</span>(c) 当c不是空格但可以打印时为真</div><div class="line"><span class="built_in">islower</span>(c) 当c是小写字母时为真</div><div class="line"><span class="built_in">isprint</span>(c) 当c是可打印字符时为真，</div><div class="line"><span class="built_in">ispunct</span>(c) 当c是标点符号时为真</div><div class="line"><span class="built_in">isspace</span>(c) 当c空白时为真</div><div class="line"><span class="built_in">isupper</span>(c) 当c是大写字符时为真</div><div class="line"><span class="built_in">isxdigit</span>(c) 当c是十六进制时为真</div><div class="line"><span class="built_in">tolower</span>(c) 如果c是大写字符，输出对应的小写字母，否则原样输出</div><div class="line"><span class="built_in">toupper</span>(c) 如果c是小写字符，输出对应的大写字母，否则原样输出</div></pre></td></tr></table></figure>
<p>建议c++版本的c标准库头文件，C++标准中除了定义C++语言的功能之外，也兼容了C语言的标准库，C语言的头文件形如 <code>name.h</code>，C++则将这些文件命名为<code>cname</code> 也就是说去掉了<code>.h</code>后缀，而在文件名<code>name</code>之前添加了字母c,这里的c表示这是一个属于C语言标准库的头文件。</p>
<p>因此， <code>cctype</code>头文件和<code>ctype.h</code>头文件的内容都是一样的，只不过通过命名规范来讲更加符合C++的语言的要求。 特别是在名为<code>cname</code>的头文件中定义的从属于命名空间 <code>std</code>而定义在名为<code>.h</code>的头文件中的则不然</p>
<h3 id="处理每个字符，使用基于范围的for语句"><a href="#处理每个字符，使用基于范围的for语句" class="headerlink" title="处理每个字符，使用基于范围的for语句"></a>处理每个字符，使用基于范围的for语句</h3><p>最好的方法是使用C++11新标准中提供的一条语句：</p>
<p>范围 for(range for)语句。</p>
<p>这种语句遍历给定序列中的每个元素并且对序列中的每个值执行某种操作。</p>
<p>语法格式： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( declaraton : expression)</div><div class="line">   statement</div></pre></td></tr></table></figure>
<p>其中，expression 部分是一个对象，用于表示一个序列，declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素，类似于Java中的for-each循环。</p>
<p>一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分，使用for循环将string对象中的字符一个接一个打印出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c: str)</div><div class="line">  <span class="built_in">cout</span>&lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>使用for(range for)改变字符串中的字符</p>
<p>如果想要改变字符串中的字符的值，必须把循环变量定义成引用类型，记住，所谓引用只是给定对象的一个别名，因此使用引用作为循环控制变量的时候，这个变量实际上一次被绑定到了每个序列的每个元素上，使用这个引用，改变它绑定的字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello,world!"</span>)</span></span>;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp;c : s)</div><div class="line">  c = <span class="built_in">toupper</span>(c);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s&lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>输出的结果为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HELLO,WORLD!</div></pre></td></tr></table></figure>
<h3 id="只处理一部分字符："><a href="#只处理一部分字符：" class="headerlink" title="只处理一部分字符："></a>只处理一部分字符：</h3><p>可以使用下标或者迭代器，我们现在只介绍下标。</p>
<p>下标运算符：（[]）接受的输入参数是 string::size_type 类型的值，这个参数表示将会访问的字符的位置，返回值是该位置的上字符的引用。</p>
<p>string 对象的下标从0开始，如果string 对象s至少包含两个字符，s[0]是第一个字符，s[s.size()-1]是最后 一个字符。</p>
<blockquote>
<p>string 对像的下标必须大于0而小于s.size()</p>
<p>使用超出此范围的下标将会引发不可预知的后果。由此推断，使用下标访问空string 也会引发不可预知的结果。和Java 会抛出越界异常不同，C++标准并不要求标准库检测下标是否合法，因此检查它是否合法的任务就必须由我们自己来完成。</p>
</blockquote>
<p>使用下标访问的方式和数组访问类似.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(s.size()) ) index = <span class="number">0</span>;index != s.size() &amp;&amp; ！<span class="built_in">isspace</span>(s[index]); ++index)</div><div class="line">   s[index] = <span class="built_in">toupper</span>(s[index]);</div><div class="line">将当前的字符串的第一个单词改成大写形式：</div><div class="line">  input: HELLO world</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> -Cpp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记(三) 类型]]></title>
      <url>/2017/11/05/CppNotes_3/</url>
      <content type="html"><![CDATA[<p>类型别名 ，auto ， decltype 关键词，自定义数据结构</p>
<a id="more"></a>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名仅仅是 一个名字，它是某种类型的同义词，使用类型别名的好处在于，使复杂的类型名字简单明了，易于理解和使用。</p>
<p>定义类型别名的两种方式：</p>
<ol>
<li><p>传统的方法是使用关键词： <code>typedef</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages ; wages 是<span class="keyword">double</span>的同义词</div><div class="line"><span class="keyword">typedef</span> wages base, *p ; base 是<span class="keyword">double</span>类型的变量，p 是<span class="keyword">double</span>指针。</div></pre></td></tr></table></figure>
</li>
<li><p>C++新标准规定了有一种方法，使用别名声明（alias declaration）来定义类型的别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> SI = Sales_items ; <span class="comment">// SI 是 Sales_item 的同义词</span></div></pre></td></tr></table></figure>
<p>这种方法规定了 <code>using</code>作为别名声明的开始，其后紧跟着别名和等号。作用是将等号左边的名字规定成等号右侧类型的别名</p>
</li>
</ol>
<h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><p>如果某个类型别名指代的是复合类型或变量，MAME吧它用到声明语句里就会产生一些意想不到的后果。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring ;</div><div class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; cstr 是指向<span class="keyword">char</span>的常量指针</div><div class="line"><span class="keyword">const</span> pstring *ps ; ps 是一个指针，它的对象会指向 <span class="keyword">char</span>的常量的指针。</div></pre></td></tr></table></figure>
<p>上面的两条语句的基本数据类型都是 const pstring 和过去一样：</p>
<p>但是，pstring 是指向 char 的指针。 所以 const pstring 就是指向 char的常量指针，而不是执行常量的字符的指针。 </p>
<p>这里的说法似乎有些拗口，简单来说，就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pstring 不是<span class="keyword">char</span> 的别名，而是指向<span class="keyword">char</span>的指针类型的别名。</div><div class="line"><span class="keyword">const</span> pstring   cstr 的实际意义是 指向<span class="keyword">char</span>类型的常量指针。</div><div class="line"><span class="keyword">const</span> pstring *ps  指向（<span class="keyword">char</span>类型的）指针 的常量指针。</div></pre></td></tr></table></figure>
<p>实际上，它确实很容易让人发生错误，因此我们在定义的时候不得不小心一点，从这一点来看，我们的生命采用前一种的方法似乎会更好一些</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring ;</div></pre></td></tr></table></figure>
<p>相比前面的定义，这样的话似乎更容易使人们注意到 pstring类型的实际意义，但是，这种小技巧并不能够解决定义指针的别名时让人混淆的问题。 对此我们只有在编写别名的时候注意尽量避免这种方式。我个人的习惯是在指针别名的时候，在别名后特意加一个<code>_ptr</code>，虽然看起来不是很美观，但某种意义上可以让自己注意到它是一个指针而不是简单的类型。像上述的命名我会写成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * number_ptr;</div></pre></td></tr></table></figure>
<p> 但是，这种蹩脚的做法有时候并不是一个很好的主意。例如我们之前举到的例子中，我们知道string 本身就是一个指向char的指针。如果我们写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *string_ptr;</div></pre></td></tr></table></figure>
<p>不仅仅很蹩脚，而且令人难以理解。</p>
<p>所以，具体采用什么方式，只好靠自己的判断了。但是，对于使用指针类型的别名，请一定要非常小心。</p>
<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>C++11新标准引入了 auto 类型的说明符，可以让编译器替我们去分析表达式所属的类型，和原来那种指定义一种特定类型的说明符，auto 通过让编译器通过初始值来推算变量的类型，显然，auto 定义的变量必须有初始值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> item = val1+val2 ;<span class="comment">//可以让item初始化为 val1 ,val2相加的结果</span></div></pre></td></tr></table></figure>
<p>例如 如果 val1和val2 都是double , 那么 item的值可以被定义为 double </p>
<p>使用 auto 也可以在一条语句中声明为多个变量，因为一条声明语句只能够有一个基本数据类型，所以，该语句中所有变量的初始和基本数据类型都必须一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> i = <span class="number">0</span> , *p = &amp;i; i 是<span class="keyword">int</span> ,p 是 <span class="keyword">int</span> 指针</div><div class="line"><span class="keyword">auto</span> sz = <span class="number">0</span> , pi = <span class="number">3.14</span> ; 这样是错误的，sz 和 pi 的类型不一致</div></pre></td></tr></table></figure>
<h3 id="复合类型，常量和auto"><a href="#复合类型，常量和auto" class="headerlink" title="复合类型，常量和auto"></a>复合类型，常量和auto</h3><p>编译器推段出来的auto值有时候和初始值的类型并不完全 一致。</p>
<p>编译器会适当的改变结果，时期更加符合初始化规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span> , &amp;r = i ;</div><div class="line"><span class="keyword">auto</span> a = r;  a 是一个整数</div></pre></td></tr></table></figure>
<p>我们知道 r 是一个引用，但是当引用被用作初始值时，真正参加初始化的实际是引用对象的值。因此编译器会将a 视作为 auto 类型。</p>
<p>需要注意的是，auto 一般会忽略掉顶层的 const , 同时底层的const则会保留下来。比如当初始值是一个指向常量的指针的时候。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i ; &amp;cr = ci ;</div><div class="line"><span class="keyword">auto</span> b = ci ;  b 是一个整数，ci的<span class="keyword">const</span> 特性被忽略掉了。</div><div class="line"><span class="keyword">auto</span> c = cr;  c是一个整数， cr 是ci的别名，ci本身 是一个顶层的 <span class="keyword">const</span></div><div class="line"><span class="keyword">auto</span> d = &amp;i ; d 是一个整形的指针</div><div class="line"><span class="keyword">auto</span> e = &amp;ci; e 是一指向整形常量的指针，常量对象取地址是一种底层 <span class="keyword">const</span></div></pre></td></tr></table></figure>
<p>我们需要推断出来的auto 类型是一个顶层的 const ,需要指明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci ; ci 的推演类型是 <span class="keyword">int</span> ,f是<span class="keyword">const</span> <span class="keyword">int</span></div></pre></td></tr></table></figure>
<p>还可以将引用的类型设置为 auto </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> &amp;g = ci;  a 是一个整形常量引用 绑定到 ci</div><div class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>; 错误，不能够为非常量引用绑定字面值</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>; 可以为常量引用绑定字面值</div></pre></td></tr></table></figure>
<p>要在一条语句中定义多个变量，切记，符号 &amp;和*只从属于声明符，而不是基本数据类型的一部分。 </p>
<h3 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h3><p>有时候希望从表达式的推断出要定义的变量的类型，但是不想用 该表达式的值初始化变量，为了满足这种需求 ，C++11引入了第二种类型说明符：</p>
<p><code>decltype</code>，它的作用是选择并且返回操作数的数据类型，在此过程中，编译器分析表达式得到它的类型却不会计算实际的值。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span> (f()) sum = x; <span class="comment">//sum 的类型就是 f的返回类型</span></div></pre></td></tr></table></figure>
<p>decltype 不会实际调用 f() 但是，但是当调用发生的时候，f的返回值类型作为 sum的类型，换句话手，编译器被sum指定的类型是什么呢，如果f被调用的话会返回的那个类型。</p>
<p>decltype 处理顶层const和引用的方式和 auto 有所不同，如果 decltype 使用的表达式是一个变量，则decltype返回该变量的类型包括 const 和引用在内</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span> , &amp;rj = ci;</div><div class="line"><span class="keyword">decltype</span>(ci) x= <span class="number">0</span> ; x 是<span class="keyword">const</span> <span class="keyword">int</span> </div><div class="line"><span class="keyword">decltype</span>(rj) y = x; y的类型是<span class="keyword">const</span> <span class="keyword">int</span>&amp; ,y绑定到变量x;</div><div class="line"><span class="keyword">decltype</span>(rj) z; 错误， z 是一个引用必须初始化</div></pre></td></tr></table></figure>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>有些表达式会向 decltype 返回一个引用类型，一般来说出现这种情况的时候，一位这该表达式的对象能够作为一条复制语句的左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span> 的结果可以是引用类型</div><div class="line"><span class="keyword">int</span> i = <span class="number">42.</span> *p = &amp;i , &amp;r = i;</div><div class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;  加法结果是<span class="keyword">int</span> ,b 是一个为初始化的<span class="keyword">int</span> </div><div class="line"><span class="keyword">decltype</span>(*p) c；c 是<span class="keyword">int</span>&amp; 必须初始化</div></pre></td></tr></table></figure>
<p>r 是一个引用，decltype(r) 的结果是一个引用类型，如果得到结果是r所指向的类型，可以将r作为表达式的一部分，r+0 ,显然这个表达式的结果将是一个具体的数值 int ,而不是一个引用。</p>
<p>如果表达式的内容是解引用操作，则decltype将得到引用类型。我们知道解指针也可以得到指针所指向的对象，而且可以对这个对象复制，因此，decltype(*p)的结果就是 一个int&amp; ,而不是 int.</p>
<blockquote>
<p>decltpye 和 auto的最为重要的区别在于：decltype的结果类型和表达式密切相关，对于decltype所用的表达式来说，如果变量名加上了一队括号，那么得到的类型和不加括号的时候会不同，因为后者编译器会把它当做一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span> 的表达式如果加上了括号的变量，结果将会是引用。</div><div class="line"><span class="keyword">decltype</span> ((i))d ; 错误，d是 <span class="keyword">int</span> &amp; 必须初始化</div><div class="line"><span class="keyword">decltype</span> (i) e; e 是一个<span class="keyword">int</span> （为初始化的）<span class="keyword">int</span></div></pre></td></tr></table></figure>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>C++语句用户以类的形式自定义数据类型，而库类型 string ,istream ostream 等都也是以类的形式定义的。 </p>
<h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><p>一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>类以关键词 struct 开始，紧紧跟着 类名和雷替，类体有花括号包围形成了一个新的作用域，类内部的名字必须唯一，但是可以和外部的名字重复。</p>
<blockquote>
<p>类体右侧的表示结束的花括号后必须加分号 ; 这是因为类体后面可以紧跟变量名以表示对该类型对象的定义，所以分号必不可少。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span>&#125; accum , trans , * sales_ptr ;</div><div class="line">可以写成另外一种方式： </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span>&#125; ; </div><div class="line">Sales_data accum, tarns ,sales_ptr;</div></pre></td></tr></table></figure>
<p>分号表示声明符（通常为空）的结束，一般来收，不要把对象的定义和类的定义放在一起。 这么做无疑是把不同实体的定义放在了一起。 在一条语句中，一会儿指定类，一会儿指定变量，是一种非常不好的习惯。</p>
<h3 id="类数据成员："><a href="#类数据成员：" class="headerlink" title="类数据成员："></a>类数据成员：</h3><p>类体定义类的数据成员，我们的类只有数据成员（data member）类的数据成员定义了对象的具体内容。 每个对象有自己的一份数据成员的copy,修改一个对象的数据成员，不会影响其他的 Sales_data 的对象。</p>
<p>定义数据成员的方式和定义普通变量一样。 </p>
<p>C++11规定，我们可以为数据成员提供一个类内的初始值。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将会被默认的初始化。</p>
<p>当然 C++中还有另外一种关键词 class 来定义自己的数据结构。</p>
<h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>为了确保各个文件中的类的定义保持一致，类通常被定义在头文件中，而且类所在的头文件的名字应该与类的名字一样。例如，库类型 string 在名为 string 的头文件中定义，Sales_data类定义在 Sales_data.h的头文件中。</p>
<p>头文件通常包含哪些只能够被定义一次的实体，如类class ,const ,constexptr 变量。 头文件也会经常 用到其他头文件的功能。例如 ，Sales_data 的成员对象中，包含了 string类，它在string.h头文件中，因此Sales_data.h就必须包含string.h 头文件，同时，使用 Sales_data的程序为了能够操作 string 成员也需要在导入 Sales_data.h 之外，再次导入 string.h</p>
<blockquote>
<p>头文件一旦改变，相关的源文件必须重新编译来获取更新过的声明。</p>
</blockquote>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>确保头文件多次包含仍然能够正确工作的是预处理器 （preprocessor）</p>
<p>C++程序还会用到的一项预处理功能就是头文件保护符（header guard）</p>
<p>预处理变量有两类，已定义和未定义。 #define 指令吧一个名字设定为 预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义。</p>
<p><code>#ifdef</code> 当且仅当变量已经定义时为真，<code>#ifndef</code>当且仅当变量未定义是为真。</p>
<p>一旦检查结果为真，将执行后续操作直到遇到 <code>#endif</code>为止。如果为假，则跳过到<code>#endif</code>之间的这段代码。使用这种功能可以有效的方式重复包含的发生。</p>
<blockquote>
<p>事实上，C++标准库中经常使用这种方式来保证和c的兼容</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> boolNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h1 id="类型是C-的基础"><a href="#类型是C-的基础" class="headerlink" title="类型是C++的基础"></a>类型是C++的基础</h1><hr>
<p>注： 以上所有内容为个人学习 C++ primer 所作的笔记。仅仅用于学习交流之用，不可以用于任何商业用途。如果想要获取更多的内容，请购买正版书籍。 </p>
<p>同时，主页的RESOURCE内提供了一个PDF版本可以参考使用。</p>
]]></content>
      
        <categories>
            
            <category> -Cpp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记（二）常量]]></title>
      <url>/2017/11/04/CppNotes_2/</url>
      <content type="html"><![CDATA[<p>关于变量和类型的更加深入的探讨。主要是关于 const 限定符。</p>
<a id="more"></a>
<h2 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h2><p>变量的定义包括一个基本数据类型（base type）和一组声明符。</p>
<p>在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。 也就说，一条定义语句可以定义出不同类型的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i ;</div><div class="line">i 是一个<span class="keyword">int</span>型的数，p是一个<span class="keyword">int</span>型指针，r是一个 <span class="keyword">int</span>型的引用。</div></pre></td></tr></table></figure>
<blockquote>
<p>基本类型和类型修饰符的关系：后者是声明符的 一部分</p>
</blockquote>
<h3 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h3><p>一种错误的观点是，在定义语句中，类型修饰符<code>* &amp;</code>作用域本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名的中间，就会一种容易产生误导的看法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* p; <span class="comment">//虽然合法但是会产生误导</span></div></pre></td></tr></table></figure>
<p>因为这种写法看起来很容易被认为就像是 int<em> 是一种类型一样，而恰恰相反，基本数据类型是 int而不是 int</em>  <code>*</code>仅仅只是用来修饰p而已。对于声明语句中的其他变量不会其任何作用。 </p>
<p>因此，需要注意的一点就是，<code>* &amp;</code>在定义变量的时候，仅仅是作为声明符的一部分，不是类型的一部分。</p>
<p>还有一种写法像这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p ;<span class="comment">//这样，将数据类型 和声明符分隔开来，就不容易产生误解了。</span></div></pre></td></tr></table></figure>
<p>前者的目的在于强调变量具有的复合类型，后者则强调本次的声明定义了 一种复合类型。</p>
<p>但是，不轮选择哪一种，关键在于尽量保持一致，不要不停的变来变去。</p>
<p>笔者采用的是后者的写法。原因是在表示一些比较复杂的修饰符时，个人认为要更加清楚。</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>一般来说，声明符中修饰符的个数没有限制。当多个修饰符连接在一起的时候，按照逻辑关系加以说明即可。 </p>
<p>例如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</div><div class="line"><span class="keyword">int</span> *pi = &amp;ival;</div><div class="line"><span class="keyword">int</span> **ppi = &amp;pi ; 指向指针的指针</div><div class="line"><span class="keyword">int</span> ***pppi = &amp;ppi; 指向指针的指针。</div></pre></td></tr></table></figure>
<p>当然了，想要访问最为原始的那个对象，需要对指针的指针进行多次的解引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"The value of ival\n"</span></div><div class="line">    &lt;&lt; <span class="string">"direct value:"</span>&lt;&lt; ival &lt;&lt;<span class="string">"\n"</span></div><div class="line">    &lt;&lt; <span class="string">"indirect value : "</span>&lt;&lt; *pi &lt;&lt;<span class="string">"\n"</span></div><div class="line">    &lt;&lt; <span class="string">"doubly indirect value: "</span>&lt;&lt;**ppi</div><div class="line">    &lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><p>引用本身就不是一个对象，因此不能够定义执行引用的指针，但是指针是对象，所以存在指针的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>; </div><div class="line"><span class="keyword">int</span> *p = ; p是一个<span class="keyword">int</span>指针</div><div class="line"><span class="keyword">int</span> *&amp;r = p ; r 是对一个指针p的引用。</div><div class="line">r = &amp;i; r 引用了 一个指针，因此给r的赋值命令时 令 p指向 i</div><div class="line">*r = <span class="number">0</span>; 解引用r得到 i,也就是p指向的对象，将 i的值改为 <span class="number">0</span>；</div></pre></td></tr></table></figure>
<p><code>*&amp;r</code>看起来可能会让人误解，最简单的一种方式是从右向左阅读r的定义，离变量名最近的符号对变量的类型有着最为直接的影响，因此<code>*&amp;r</code>可以这么理解，oh，我们从右边看，r是一个引用，引用了一个指针。这个指针指向一个 int</p>
<blockquote>
<p>面对一个非常复杂的指针或者是引用的声明语句时，从右往左阅读有助于弄明白它的真实含义。这也是我为什么选择第二种写法的原因，</p>
</blockquote>
<h2 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h2><p>const 关键词可以保证变量的值不能够被改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> butSize = <span class="number">512</span>; <span class="comment">//butSize 一次赋值后不能够改变，这样就让 butSize成为了 一个常量。任何的试图对butSize的修改行为都会引发错误。</span></div></pre></td></tr></table></figure>
<h3 id="初始化和-const"><a href="#初始化和-const" class="headerlink" title="初始化和 const"></a>初始化和 const</h3><p>对象的类型决定了其上能够进行的操作，const 类型的对象可以完成所有不改变类型的操作，可以进行运算，也可以转换成以bool,有些时候，这也是我们想看到的。</p>
<p>当然我们 const对象的操作中还有一种就是初始化，如果用一个对象去初始化另外一个对象，那么是否是const都无关紧要。重要的是，我们知道，一旦const对象获取了一个值（初始化）后，就无法再次对它进行任何的修改。</p>
<h4 id="默认状态下，const对象仅仅在文件内有效"><a href="#默认状态下，const对象仅仅在文件内有效" class="headerlink" title="默认状态下，const对象仅仅在文件内有效"></a>默认状态下，const对象仅仅在文件内有效</h4><p>非常好理解，我们知道如果我们初始化定义一个const对象时，编译器就在编译过程中将有用到该变量的地方都转换成一这个初始值，前提是，编译器必须找到初始值，如果const对象可以存在多个文件中，为了让编译器得到它的初始值，就必须在多个文件中反复定义这个const对象，显然这样做是不合理的（笔者的理解，反复定义这种手段其实就相当于在每个文件内重新定义了一个新的const对象，我们还需要维护它们的签名是相同的，是很不明智的做法，与其如此，还不如直接要求const对象仅仅在本文件内有效，这样就避免了程序员在多个文件中引用相同的const签名带来的麻烦,但是我们也无法忽视这样一种需求：我们有时候确实需要一种const变量它的初始值不是 一个常量表达式，但是的确 有必要在文件间共享，我们想让这类const对象像其他非const对象 一样工作，解决的方式是，无论是定义还是声明都添加 extern 关键词 ，这样就只需要定义一次就好了，个人认为extern实际上为编辑器提供了一种管理const的机制。）</p>
<p>因为：如果我们想要定义一个常量而且希望它能够在文件间共享</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file.cpp</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = fxn();</div><div class="line">在另外一个文件中</div><div class="line"><span class="comment">//file2.cpp</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize ; bufSize 和 前一个文件中定义的是同一个 bufSize</div></pre></td></tr></table></figure>
<p>因此特别注意：</p>
<blockquote>
<p>如果想要在多个文间之间共享 const对象，就必须在变量的定义之前添加 extern 关键词</p>
</blockquote>
<h2 id="const-的-引用"><a href="#const-的-引用" class="headerlink" title="const 的 引用"></a>const 的 引用</h2><p>可以把引用绑定到 const对象上，我们称之为 对常量的引用 （reference to cosnt） 和普通引用的不同仅仅在于，不能偶修改它所绑定的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rci = ci;</div><div class="line">rci = <span class="number">42</span>;会出错，试图修改对常量的引用。</div><div class="line"><span class="keyword">int</span> &amp;rci2 = ci; 错误，试图将一个非常量的引用绑定到一个常量的对象上</div></pre></td></tr></table></figure>
<h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>引用的类型必须和其被引用的对象的类型一致，但是有两个例外，一种就是初始化常量引用时允许任意的表达式作为初始值。只要该表达式的结果能够转换为一引用的类型即可。尤其是，允许为一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>; </div><div class="line">coust <span class="keyword">int</span> &amp;rl = i ; 正确 r1 是一个常量引用</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>; 正确</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span> ; 正确</div><div class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span> ; 错误，r4是一个非常量引用。</div></pre></td></tr></table></figure>
<blockquote>
<p>必须认识到的 一点就是：对const的引用可能引用 一个非const的对象。常量仅仅对引用可以参与的操作做出了限定，对引用的对象本身是否是 常量未作出任何的限定。因此对象也可以是一个非常量，只是不能从const引用改变它的值，我们任然可以从其他地方改变它的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line">&gt; <span class="keyword">int</span> &amp;r1 = i;</div><div class="line">&gt; <span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</div><div class="line">&gt; r1 = <span class="number">0</span>;可以，因为rl非常量引用</div><div class="line">&gt; r2 = <span class="number">0</span>; 错误，不能修改<span class="keyword">const</span>引用</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>和引用一样，也可以令指针指向常量或者非常量，指向常量的指针。不能够用于改版其所指向对象的值，要想存放常量对象的地址，只能够使用指向常量的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</div><div class="line"><span class="keyword">double</span> *ptr = &amp;pi; 错误。ptr是一个普通指针</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; 正确</div><div class="line">*cptr = <span class="number">40</span> ; 错误，不能对*cptr赋值</div></pre></td></tr></table></figure>
<p>其他特性和引用基本一样，不再赘述。</p>
<h4 id="换一个角度，我们可以这样想，所谓的指向常量的指针或者是引用，不过是指针后者引用自以为是的认为罢了，他们觉得自己指向了常量，所以不会去修改所指对象的值。"><a href="#换一个角度，我们可以这样想，所谓的指向常量的指针或者是引用，不过是指针后者引用自以为是的认为罢了，他们觉得自己指向了常量，所以不会去修改所指对象的值。" class="headerlink" title="换一个角度，我们可以这样想，所谓的指向常量的指针或者是引用，不过是指针后者引用自以为是的认为罢了，他们觉得自己指向了常量，所以不会去修改所指对象的值。"></a>换一个角度，我们可以这样想，所谓的指向常量的指针或者是引用，不过是指针后者引用自以为是的认为罢了，他们觉得自己指向了常量，所以不会去修改所指对象的值。</h4><h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>指针使用中需要注意的一点是，指针是对象。引用 不是，所以可以将指针本身定位常量，常量指针必须初始化，一旦初始化完场不能够改变其值了。它的声明方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;</div></pre></td></tr></table></figure>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>顶层 const (top level const)表示指针本身是个变量，</p>
<p>底层 const （low level const） 表示指针所指向的对象是一个常量。</p>
<p>更加一般的是，顶层const可以表示 任意的对象是常量，但是指针既可以是顶层也可以是底层。</p>
<p>在执行对象的copy操作时，顶层还是底层的const差别明显。其中顶层的const不受影响。因为执行copy不会改变 对象的值，和对象是常量和变量都没有什么影响。 </p>
<p>另一方面，底层的const的限制却不能忽视，当执行对象的copy操作时，拷入和拷出不需具有相同的底层const资格。或者这两个对象的类型必须能够转换。</p>
<p>一般来说，非常量可以转换成常量，反之不行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i; 不能够改变 p1 的值，底层 顶层 <span class="keyword">const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;   不能够改变 ci的值，ci是一个顶层的<span class="keyword">const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;  允许改变p2 的值，这是一个底层的 <span class="keyword">const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; 靠右是一个顶层的<span class="keyword">const</span> 左的是一个顶层<span class="keyword">const</span></div><div class="line">cosnt <span class="keyword">int</span> &amp;r = ci;  引用的cosnt是一个底层的<span class="keyword">const</span>;</div><div class="line">i = ci; ci 是一个顶层的cosnt 此操作无影响</div><div class="line">p2 = p3 ; 正确，p2 和p3指向 的数据类型相同p3 的顶层部分不受影响。</div><div class="line"><span class="keyword">int</span> *p = p3; 错误，p3包含底层<span class="keyword">const</span>的定义，p没有</div><div class="line">p2 = p3; 正确，都是底层的<span class="keyword">const</span></div><div class="line">p2 = &amp;i; 正确，<span class="keyword">int</span>* 可以转化成 <span class="keyword">const</span> <span class="keyword">int</span> *</div><div class="line"><span class="keyword">int</span> &amp;r = ci; 错误，普通的<span class="keyword">int</span>&amp; 不能够绑定到 <span class="keyword">int</span>常量上</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i; 正确</div></pre></td></tr></table></figure>
<h2 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h2><p>constexpr 声明中如果定义了一个指针，限定符 constexpr只对指针有效，对所指的对象无关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span> ; p是一个指向整数常量的指针</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>; q是一个指向整数的常量指针</div></pre></td></tr></table></figure>
<blockquote>
<p>constexpr 将他定义的对象设置为了一个顶层的const.</p>
<p>和其他常量指针类似，constexpr 指针既可以指向常量，也可以指向非常量</p>
</blockquote>
<hr>
<p>注： 以上所有内容为个人学习 C++ primer 所作的笔记。仅仅用于学习交流之用，不可以用于任何商业用途。如果想要获取更多的内容，请购买正版书籍。 </p>
<p>同时，主页的RESOURCES 内提供了一个PDF版本可以参考使用。</p>
]]></content>
      
        <categories>
            
            <category> -Cpp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记（一） 变量和类型]]></title>
      <url>/2017/11/04/CppNotes_1/</url>
      <content type="html"><![CDATA[<p>本人学习C++所做的笔记。本节主要是关于C++的变量和基本类型</p>
<a id="more"></a>
<h2 id="基本内置类型："><a href="#基本内置类型：" class="headerlink" title="基本内置类型："></a>基本内置类型：</h2><p>C++定义了一套包含算数类型（arithmetic type ）和空类型（void）在内的基本数据类型。</p>
<h4 id="算数类型："><a href="#算数类型：" class="headerlink" title="算数类型："></a>算数类型：</h4><p>算数类型的尺寸在不同的基础上有所区别。下表是C++标准规定的尺寸的最小值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">类型                 含义            最小尺寸</div><div class="line"><span class="keyword">bool</span>               布尔类型             未定义</div><div class="line">(u)<span class="keyword">char</span>                字符                 <span class="number">8</span>位</div><div class="line"><span class="keyword">wchar_t</span>             宽字符              <span class="number">16</span>位</div><div class="line"><span class="keyword">char16_t</span>           Unicode字符          <span class="number">16</span>位</div><div class="line"><span class="keyword">char32_t</span>           Unicode字符          <span class="number">32</span>位</div><div class="line">(u)<span class="keyword">short</span>              短整型               <span class="number">16</span>位</div><div class="line">(u)<span class="keyword">int</span>                整形                 <span class="number">16</span>位</div><div class="line">(u)<span class="keyword">long</span>                 长整形             <span class="number">32</span>位</div><div class="line">(u)<span class="keyword">long</span> <span class="keyword">long</span>            长整形             <span class="number">64</span>位</div><div class="line"><span class="keyword">float</span>               单精度浮点          <span class="number">6</span>位有效数字</div><div class="line"><span class="keyword">double</span>              双精度             <span class="number">10</span>有效数字</div><div class="line"><span class="keyword">long</span> <span class="keyword">double</span>       扩展精度浮点        <span class="number">10</span>位有效数字</div></pre></td></tr></table></figure>
<p>在C++中除去了布尔型和可以扩展的字符型之外，其他整形可以划分为带符号和无符号的两种用 <code>signed</code>和<code>unsigned</code>两种。（在Java中不存在无符号整形）</p>
<h4 id="如何选择类型"><a href="#如何选择类型" class="headerlink" title="如何选择类型"></a>如何选择类型</h4><ol>
<li>知晓数值不可能为负，选用无符号类型</li>
<li>使用int 进行整数运算</li>
<li>执行浮点运算使用 double</li>
</ol>
<h2 id="类型转换-convert"><a href="#类型转换-convert" class="headerlink" title="类型转换(convert)"></a>类型转换(convert)</h2><p>类型所能够表示的范围决定了转换的过程</p>
<ol>
<li>当一个非bool的值赋值给bool时，0为false,其他为 true</li>
<li>将 bool 赋值给非 bool , false为 0，true 为 1</li>
<li>将浮点赋值给 整形时，将小数点后的数位截断，保留整数部分</li>
<li>整数赋值给浮点的时候，小数部分记为<code>.0</code></li>
<li>当给 一个无符号类型一个超过其范围的值的时候，结果是初始值对无符号类型表示数值总数取模后的余数，举个例子： 一个8位的unsigned char 可以表示 0-255 区间内的值，如果我们赋了一个区间以外的值，实际的结果是该值对256取模后的余数，因此，把-1给0比特大小的unsigned char 所得到的结果是 255</li>
<li>当我们复制给带符号类型一个超出表示范围的值时，结果是未定义的，程序可能够继续工作，也可能崩溃，也可能生成垃圾数据；</li>
</ol>
<h2 id="字面值常量（literal）"><a href="#字面值常量（literal）" class="headerlink" title="字面值常量（literal）"></a>字面值常量（literal）</h2><h3 id="整形和浮点型字面值"><a href="#整形和浮点型字面值" class="headerlink" title="整形和浮点型字面值"></a>整形和浮点型字面值</h3><p>可以将整形的字面值写作 10进制，八进制，16进制的形式。从0开头的整数表示八进制，0x或者0X开头的表示 16进制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">20</span> <span class="comment">/*10进制*/</span></div><div class="line"><span class="number">024</span> <span class="comment">/*8进制*/</span></div><div class="line"><span class="number">0x14</span> <span class="comment">/*16进制*/</span></div></pre></td></tr></table></figure>
<p>默认的浮点字面值是一个double ,当然了我们可以使用响应的后缀表示其他的类型。其表示方法是一个小数或者是科学计数法表示的指数，其中指数部分使用<code>E</code>或者<code>e</code>中的后缀来表示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">3.14159</span></div><div class="line"><span class="number">3.14159E0</span></div><div class="line"><span class="number">0.</span></div><div class="line"><span class="number">0e0</span></div><div class="line"><span class="number">.001</span></div></pre></td></tr></table></figure>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><p>用单引号括起来的一个字符称为是 char 型的字面值。</p>
<p>双引号括起来的多个字符构成字符串字面值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'a'</span> <span class="comment">/*字符字面值*/</span></div><div class="line"><span class="string">"Hello"</span> <span class="comment">/*字符串字面值*/</span></div></pre></td></tr></table></figure>
<p>字符串的字面值实际上是由常量的字符构成的数组（array）,编译器后在每个字符串的结尾处加上一个空字符<code>\0</code>，因此，字符串字面值的长度比实际长度要小一位。</p>
<p>如果两个字符串字面值相邻而且仅仅 由空格缩进和换行符分割，则它们实际上是一个整体当书写的字符串字面值比较长的时候，可以采取分开书写的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a really ,really long string literal "</span></div><div class="line">  <span class="string">"that spans two lines"</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>有两种字符是不能够直接使用的，</p>
<ol>
<li>不可打印字符如退格符，或者其他控制字符（常用与数据通信控制）</li>
<li>在C++中含有特殊含义的字符。</li>
</ol>
<p>这些情况下使用到转移序列，均以反斜杠开始，C++中的转义字符包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\n \t \a \v \b \<span class="string">" \' \\ \?  \r \f</span></div></pre></td></tr></table></figure>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>通过添加前缀或者是后缀可以改变整形，浮点型和字符型字面值的默认类型.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">L'a'   宽字符类型字面值， <span class="keyword">wchar_t</span></div><div class="line"><span class="string">u8"hi!"</span> utf<span class="number">-8</span> 字符串字面值</div><div class="line"><span class="number">42U</span>LL 无符号整形字面值，类型是 <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> </div><div class="line"><span class="number">1E-3</span>F 单精度的浮点型字面值， 类型是 <span class="keyword">float</span></div><div class="line"><span class="number">3.14159L</span>  类型是 <span class="keyword">long</span> <span class="keyword">double</span></div></pre></td></tr></table></figure>
<p>指定字符字面值的类型：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>Unicode16</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode32</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8</td>
<td>char</td>
</tr>
</tbody>
</table>
<p>整形字面值：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l or L</td>
<td>long</td>
</tr>
<tr>
<td>ll or LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
<p>浮点型字面值：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>f 或 F</td>
<td>float</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>定义格式：  &lt;类型&gt;  变量名  [= 初始值] ;</p>
</blockquote>
<p>默认初始化：</p>
<p>如果定义变量时没有指定初值，则变量被默认初始化。此时变量被赋予了默认值。如果内置类型的变量未被显式的初始化，它的值由定义的位置决定，定义于任何函数体之外的变量被初始化为0，<strong>一种例外情况是，定义在函数体内部的内置类型变量将不会被初始化。</strong> 一个未被初始化的内置类型变量的值是未定义的，如果试图copy或者以其他形式的访问此值将引发错误。</p>
<blockquote>
<p>需要注意的是，即便是 java 定义函数体内部的内置类型也也不会被初始化。</p>
<p>但是，在Java中如果没有进行初始化，编译器会抛出 类似于</p>
<p>Exception in thread “main” java.lang.Error: Unresolved compilation problem: 的异常，但是，在C++中，我们不得不去注意它带来的种种问题。 </p>
</blockquote>
<p>每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也有类自己决定。如果类允许这种决定，它将决定类的对象的初始化到底是什么。</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>为了允许把程序拆分成多个逻辑部分来编写，C++支持分离式编译机制，允许将程序分割成若干个文件，每个文件可以被独立编译。</p>
<p>如果将程序分为多个文件，则需要在 有文件间共享代码的方法，例如： 一个文件的代码可能需要使用另一个文件中定义的变量。</p>
<p>为了支持分离式编译，C++将声明和定义分离开来，</p>
<p>声明（declaration） 使得名字为程序所知，一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明，而</p>
<p>定义负责创建与名字关联的实体。</p>
<p>变量声明规定了变量的类型和名字，在这一点上定义与之相同，<strong>但是除此之外，定义还申请存储空间，也可能够为变量赋一个初始值。</strong></p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键词 extern 而且不要显式的初始化变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i ;<span class="comment">//声明i 而非定义 i</span></div><div class="line"><span class="keyword">int</span> j ;<span class="comment">//声明定而非定义 j</span></div></pre></td></tr></table></figure>
<p>包含了显式初始化的声明即成为定义。我们能够给 由 extern 关键词标记的变量赋的是一个初值。但是这么做也就是抵消了extern 的作用，extern 语句如果包含初始值就不再是声明，而变成了定义了。</p>
<p>在函数体内部，如果试图初始化一个由 extern 关键词标记的变量，将引发错误</p>
<h4 id="变量能且只能被定义一次，但是可以被多次声明。"><a href="#变量能且只能被定义一次，但是可以被多次声明。" class="headerlink" title="变量能且只能被定义一次，但是可以被多次声明。"></a>变量能且只能被定义一次，但是可以被多次声明。</h4><p>C++是一种静态类型语言（statically typed）语言，其含义是在编辑阶段检查类型，其中检查类型的过程称之为类型检查（type checking）</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C++标识符由字符,数字和下划线组成，其中必须以字母或下划线开头，标识符的长度没有限制，但是对大小写字母敏感。</p>
<ol>
<li>标识符要能够体现实际意义</li>
<li>变量名一般用小写字母，如 index ,不要使用 Index, INDEX</li>
<li>用户自定义的类名一般以大写字母开头，如 Sales_item</li>
<li>如果标识符由多个单词组成，则单词键要有明显的区分，如 student_loan 或者studentLoan, 不要使用 studentloan </li>
</ol>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>不论在程序的什么位置，使用到每个名字都会指向一个特定的实体，变量，函数，类型等，同一个名字出现杂程序的不同的位置，也可能指向的是不同尸体。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域以花括号分隔</p>
<p>同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用 域末端为结束。</p>
<h4 id="嵌套的作用域："><a href="#嵌套的作用域：" class="headerlink" title="嵌套的作用域："></a>嵌套的作用域：</h4><p>作用域能彼此包含，被包含（或者被说被嵌套）的作用域被称为内层作用域，包含着别的作用域的作用域称为外层作用域（outer scope）</p>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>复习类型是基于其他类型定义的类型，C++中有很多的数学类型，典型的两种：指针，引用</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>严格来说，当我们使用引用，引用（reference）为对象起了另外一个名字，引用类型引用(refers to) 另外 一种类型，通过将声明写成 &amp;d 的形式来定义引用类型，其中d是声明的变量名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</div><div class="line"><span class="keyword">int</span> &amp;refval = ival; refVal 指向ival(是ival另外一个名字)</div><div class="line"><span class="keyword">int</span> &amp;refval2 ; <span class="comment">//报错，引用必须被初始化</span></div></pre></td></tr></table></figure>
<p>一般在初始化变量时，初始值会被copy到新建的对象中，然而定义引用的时候，程序把引用和它的初始值 bind绑定在一起，而不是将初始值copy给引用，一旦初始化完成，引用将和它的初始对象一直绑定在一起。 因此无法令 引用重新绑定到另外一个对象，因此引用必须初始化</p>
<p>引用即别名：</p>
<p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p>
<p>定义了一个引用之后，对其进行的所有的操作都是在与之绑定的对象进行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">refVal = <span class="number">2</span>; <span class="comment">//把2赋给refVal 指向的对象，此处即使赋给了ival;</span></div><div class="line"><span class="keyword">int</span> li = reVal ;<span class="comment">//与 li = ival 执行结果一样</span></div></pre></td></tr></table></figure>
<p>为引用赋值，实际上是把赋值给了与引用绑定的对象，获取引用的值，实际上是获取了去了与引用绑定的对象的值，同理，以引用作为引用值，实际上是以与引用绑定的对象作为初始值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> &amp;refVal3 = reVal;</div><div class="line">正确： refVal3 绑定到了那个与refVal 绑定的对象，这里就是绑定到 ival上。</div><div class="line"><span class="keyword">int</span> i = refVal ;<span class="comment">//正确：i被初始化为 ival 的值。</span></div></pre></td></tr></table></figure>
<p>因为引用本身不是一个对象，所以不能够定义为 引用的 引用。</p>
<p>引用的定义：</p>
<p>允许在一条语句中定义多个引用，其中每个标识符都必须以符号&amp;开头。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1024</span> , i2 = <span class="number">2048</span> ; i1 和 i2 都是  <span class="keyword">int</span></div><div class="line"><span class="keyword">int</span> &amp;r = i; r2= i2;  r是一个引用，与i绑定在一起，r2 是<span class="keyword">int</span> </div><div class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;  i3 是<span class="keyword">int</span> ,ri 是一个引用，与i3 绑定在一起</div><div class="line"><span class="keyword">int</span> &amp;r3 = i3; &amp;r4 = i2; r3 和 r4 都是引用。</div></pre></td></tr></table></figure>
<p>将要介绍的介绍的两种例外的情况，其他所有的引用的类型都要与与之绑定的对象严格匹配，而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span> ;错误，引用类型的初始值必须是一个对象</div><div class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</div><div class="line"><span class="keyword">int</span> &amp;refVal5 = dval ; <span class="comment">//错误： 此处引用类型的初始值必须是int型对象</span></div></pre></td></tr></table></figure>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针 pointer 是指向 point to 另外一种类型的符合类型，与引用类似，指针也实现了对其他对象的间接访问，然而指针与引用相比又有很多的不同点，其一，指针本身也就是一个对象，允许对指针赋值和copy,而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无需在定义时赋值，和其他内置类型一样，这块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
<p>定义指针类型的方法将声明符写成<em>d的形式，其中 d 是变量名，如果在一条语句中定义了几个指针变量，每个变量前面必须有符号 </em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>  * ip1 , * ip1 ; ip1 和 ip2 都是指向 <span class="keyword">int</span> 型对象的指针</div><div class="line"><span class="keyword">double</span> dp , * dp2 ; dp2 是指向<span class="keyword">double</span>型对象的指针中，dp 是<span class="keyword">double</span> 型对象</div></pre></td></tr></table></figure>
<h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3><p>指针存放某个对象的地址，要想获取该地址，需要使用 <strong>取地址符</strong>(操作符 &amp;)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival ; <span class="comment">//p 存放变量ival的地址，或说p 是真相变量 ival 的指针</span></div></pre></td></tr></table></figure>
<p>所有的指针类型都要和它所指向的对象严格匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> dval ;</div><div class="line"><span class="keyword">double</span> *pd = &amp;dval ; </div><div class="line"><span class="keyword">double</span> *pd2 = pd; </div><div class="line"><span class="keyword">int</span> *pi = pd; 错误，指针p的类型和pd的类型不匹配</div><div class="line">pi = &amp;dval ; 错误，视图吧<span class="keyword">double</span> 类型的指针赋值给<span class="keyword">int</span>型指针。</div></pre></td></tr></table></figure>
<p>一个指针的值（即地址）应该满足一下四种状态之一：</p>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象向所占有空间的下一个位置。</li>
<li>空指针，指针没有指向任何对象</li>
<li>无效指针，上述情况之外的其他值</li>
</ol>
<p>视图去copy或者访问无效指针的值都会引发错误，编译器不会检查此类错误这一点和视图使用未经过初始化的变量是一样的，</p>
<p>####利用指针访问对象</p>
<p>如果访问了一个对象，则允许使用解引用符(操作符 *)来访问对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival ; p 存放着变量 ival 的地址，或者说 p 是指向变量 ival的指针</div><div class="line"><span class="built_in">cout</span>&lt;&lt; *p ; 由符号 * 得到指针p 所指向的队形，输出 <span class="number">42</span>；</div><div class="line">*p = <span class="number">0</span>;  有符号 * 得到指针 p 所指的对象，即可经由p为变量 ival 赋值</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *p; 输出 <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当引用操作仅仅适用于那些确实指向了某个对象的有效指针</p>
<h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>空指针（null pointer） 不指向任何对象，在试图使用一个指针之间代码可以首先检查它是否为空，以下列出几个生成空指针的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;  等价于 <span class="keyword">int</span> *p1 = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;  直接将p2初始化为字面常量 <span class="number">0</span></div><div class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span> ; 等价于 <span class="keyword">int</span> *p3 = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>得到空指针的最直接的方法是用字面值 nullptr 来初始化指针，这也是 C++11标准最新引入的一种方法，nullptr 是一种特殊类型的字面值。 他可以转换为任意其他类型的指针，另一种方法试试可将指针初始化为 0 来生成空指针。</p>
<p>过去的程序还会用到一个名为 NULL 的预处理变量，（preprocessor variable）来个指针赋值，这个变量在头文件 <code>cstdlib</code>中的定义，它的值就是 0</p>
<p>但是需要知道的是，尽管我们说 nullptr 和NULL 它在定义时值确实是0，但是我们一定要知道的是，将 int 变量的值恰好等于0也不行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</div><div class="line">pi = zero; <span class="comment">//错误：不能把int 变量直接赋给指针</span></div></pre></td></tr></table></figure>
<h4 id="复制和指针"><a href="#复制和指针" class="headerlink" title="复制和指针"></a>复制和指针</h4><p>指针和引用都能提供对其他对象的简介访问，然而在具体是实现细节上二者有很大的不同，其中最重要的一点就是引用本身并非一个对象，一旦定义了引用，就无法令其再绑定到另外的对象。之后每次访问这个引用都是直接访问它最初的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>; </div><div class="line"><span class="keyword">int</span> *pi = <span class="number">0</span> ; pi被初始化，没有指向任何对象</div><div class="line"><span class="keyword">int</span> *pi2 = &amp;i; </div><div class="line"><span class="keyword">int</span> *pi3 ; pi3 定义与块内，则pi3的值是无法确定的。</div><div class="line">pi3 = pi2; pi3 和 pi2 指向同一个对象 存有 i 的地址</div><div class="line"><span class="keyword">int</span> *pi3 ; 如果pi3 定义与快内，则 pi3 的值是无法确定的</div><div class="line">pi3 = pi2; pi3 和 pi2 指向同一个对象</div><div class="line">pi2 = <span class="number">0</span> ; 现在 pi2 不指向任何对象了</div></pre></td></tr></table></figure>
<p>有时候要搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指向的对象的值不太容易，最好的方法就是记住赋值永远改变的是等号左侧的对象。</p>
<p>当我们写出如下的语句的时候，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pi = &amp;ival ; pi 的值会改变，现在pi指向了 ival </div><div class="line">*pi = <span class="number">0</span>  ; ival 的值会被该表，指针 pi 并没有改变</div></pre></td></tr></table></figure>
<h4 id="其他的指针操作"><a href="#其他的指针操作" class="headerlink" title="其他的指针操作"></a>其他的指针操作</h4><p>对于两个类型相同的合法指针，就可以把它用在条件表达式中，和采用算术值作为条件遵循的规律类似，如果指针的值为0，条件 为false ,非0 ，true</p>
<p>对于类型相同的合法指针，可以使用相等的 <code>==</code>和 不等<code>==</code>操作符来比较他们比较的结果是bool.</p>
<h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void * 指针"></a>void * 指针</h4><p>void*是一种特殊的指针类型，可以用于存放任意对象的地址，一个指针存放地址这一单和其他的指针类似，不同的是，我们对该地址中到底是一个什么类型的对象并不了解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</div><div class="line"><span class="keyword">void</span> * pv = &amp;obj ; 正确，<span class="keyword">void</span> * 能够存放任意类型的对象</div><div class="line"><span class="keyword">void</span> * pv = &amp;obj ; obj可以是任意类型你的对象。</div><div class="line">pv = pd; pv 可以存放任意类型的指针</div></pre></td></tr></table></figure>
<p>利用void<em> 指针所能够做的事情比较有限，那他和别的指针比较，作为函数的输入和输出，后者复制为另外一个void</em> 指针，不能够直接操作 void* 所指向的对象，因为无法确定这个对象是什么类型。 也就无从得知要怎么操作这个对象</p>
<p>概括说来，void* 视角来看内存空间也就仅仅是内存空间，无法访问内存空间中的对象。当然我们也可以考虑对它进行转型，但是现在暂时不会讨论这个问题。</p>
<hr>
<p>注： 以上所有内容为个人学习 C++ primer 所作的笔记。仅仅用于学习交流之用，不可以用于任何商业用途。如果想要获取更多的内容，请购买正版书籍。 </p>
<p>同时，主页的RESOURCES内提供了一个PDF版本可以参考使用。</p>
]]></content>
      
        <categories>
            
            <category> -Cpp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java简单的图形界面设计(二)布局管理器]]></title>
      <url>/2017/11/03/SimpleJavaSwing2/</url>
      <content type="html"><![CDATA[<h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><p>布局管理器是指窗口上的组件遵循一定的规则来排列，并且会随着窗口大小的变化来改变组件大小与位置的一种布局方式。Java语言的布局管理器所提供的自动布局功能来进行页面设置，则可以自动的排列与管理窗口中的组件。也就是说，当为一个容器指定一个布局管理器后，则将每当一个组件加入到该容器中时，布局管理器就可以自动的设置该组件的位置的位置和大小。当容器改变大小的时候，布局管理器能自动调整其中组件的位置和大小。用户可以为容器指定不同的布局管理器，在不同的管理布局器下，同一个组件可以有不同的显示效果。</p>
<a id="more"></a>
<p>java.awt 包中共定义了五中布局管理器，每个布局管理器对应一种布局策略。分别是流式布局管理器（FLowLayout）边界式布局管理器 (BorderLayout)，卡片式布局管理器（CardLayout）,网格式布局管理器（GridBayLayout）。javax.swing 包中还有盒式布局管理器（BoxLayout）重叠布局管理器（OverLayout）和弹簧式布局管理器 SpringLayout 等。</p>
<h2 id="流式布局管理器-FlowLayout"><a href="#流式布局管理器-FlowLayout" class="headerlink" title="流式布局管理器 FlowLayout"></a>流式布局管理器 FlowLayout</h2><p>流式布局是一种最基本的布局。它是一种流式页面设计。流式布局管理器的的布局策略：</p>
<ol>
<li>组件按照加入容器的先后顺序从左到右排列。</li>
<li>一行排满之后就会自动地转到下一行继续从左到右。</li>
<li>每一行中的组件默认设置为居中排列</li>
<li>FlowLayout 布局管理器是JPanel 默认的布局管理方式</li>
</ol>
<p>##构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlowLayout</span><span class="params">()</span> 创建 FlowLayout 布局管理器，容器中的对象居中对齐，对象的垂直和水平间距默认均为5个像素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlowLayout</span><span class="params">( <span class="keyword">int</span> align)</span> 创建同上功能的布局管理器，指定对齐方式</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlowLayout</span><span class="params">(<span class="keyword">int</span> align , <span class="keyword">int</span> hvap , <span class="keyword">int</span> vgap)</span> 创建同上具有对齐功能的布局管理器，但对象的水平间距为 hgap 个像素，垂直间距为 vgap 个像素</span></div></pre></td></tr></table></figure>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHap</span><span class="params">()</span> 返回该布局管理器中各组件之间水平间距的像素数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVgap</span><span class="params">()</span> 返回布局管理器之间组件之间水平间距的像素数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHgap</span><span class="params">(<span class="keyword">int</span> hgap)</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVgap</span><span class="params">(<span class="keyword">int</span> vgap)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setAlignment</span><span class="params">(<span class="keyword">int</span> align)</span> 设置布局管理器的对齐方式</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAlignment</span><span class="params">()</span> 设置布局管理器的对齐方式</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutContainer</span><span class="params">(Container target)</span> 设置target容器组件的布局方式为FlowLayout .</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLayoutComponent</span><span class="params">(String name,Component comp)</span> 指定的组件加入到布局管理器中，使用的指定的名称</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLayoutComponent</span><span class="params">(Component comp)</span> 将指定组件从该布局管理器中删除</span></div></pre></td></tr></table></figure>
<p>一个简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_8</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</div><div class="line">	<span class="keyword">static</span> JFrame frm = <span class="keyword">new</span> JFrame(<span class="string">"流式布局管理器FlowLayout"</span>);</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		</div><div class="line">		FlowLayout flow = <span class="keyword">new</span> FlowLayout(FlowLayout.CENTER,<span class="number">5</span>,<span class="number">10</span>);</div><div class="line">		JButton but = <span class="keyword">new</span> JButton(<span class="string">"按钮"</span>);</div><div class="line">		JLabel lab = <span class="keyword">new</span> JLabel(<span class="string">"我是一个标签"</span>);</div><div class="line">		frm.setLayout(flow);</div><div class="line">		frm.setSize(<span class="number">260</span>, <span class="number">150</span>);</div><div class="line">		frm.add(but);</div><div class="line">		frm.add(lab);</div><div class="line">		frm.add(<span class="keyword">new</span> JTextField(<span class="string">"流式布局策略 FlowLayout"</span>,<span class="number">18</span>));</div><div class="line">		frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		frm.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<h2 id="边界布局管理器-BorderLayout"><a href="#边界布局管理器-BorderLayout" class="headerlink" title="边界布局管理器 BorderLayout"></a>边界布局管理器 BorderLayout</h2><p>边界式布局管理器 BorderLayout 将显示区域按地理方位分为东East,西(West),南（South),北(North),中(Center)5个区域。在将组件加入容器时，都应该指出将组件加入到那个区域中，若没有指定区域，则默认为中间，将组件加入到已被其他组件占用的区域，将会取代原先的组件。BorderLayout 是容器JFrame ,JApplet 和对话框组件JDialog默认使用的布局管理器。</p>
<p>分布在北部和南部区域的组件将横向扩展至占据整个容器的长度，分布在东部和西部将伸展至占据容器剩余部分的全部高度，最后剩余的部分将分配给位于中央区的组件。如果某个区域没有分配组件。则其他组件可以占据它的空间。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BorderLayout</span><span class="params">()</span> 创建BorderLayout 布局管理器，容器中的个对象之间没有问题。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BorderLayout</span><span class="params">()</span> 创建BorderLayout 布局管理器，容器中组件之间的水平间隔为 hgap , 垂直间隔为 vgap 个像素</span></div></pre></td></tr></table></figure>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>和流式布局基本相同。</p>
<p>一个简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_9</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> JFrame  frm = <span class="keyword">new</span> JFrame(<span class="string">"边界式布局管理器 BorderLayout"</span>);</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		BorderLayout border = <span class="keyword">new</span> BorderLayout(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line">		frm.setLayout(border);</div><div class="line">		frm.setSize(<span class="number">330</span>,<span class="number">200</span>);</div><div class="line">		frm.add(<span class="keyword">new</span> JButton(<span class="string">"上北"</span>), BorderLayout.NORTH);</div><div class="line">		frm.add(<span class="keyword">new</span> JButton(<span class="string">"下南"</span>), BorderLayout.SOUTH);</div><div class="line">		frm.add(<span class="keyword">new</span> JButton(<span class="string">"左西"</span>), BorderLayout.WEST);</div><div class="line">		frm.add(<span class="keyword">new</span> JButton(<span class="string">"右东"</span>), BorderLayout.EAST);</div><div class="line">		frm.add(<span class="keyword">new</span> JButton(<span class="string">"中央"</span>), BorderLayout.CENTER);</div><div class="line">		frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		frm.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<h2 id="网格布局管理器-GridLayout"><a href="#网格布局管理器-GridLayout" class="headerlink" title="网格布局管理器 GridLayout"></a>网格布局管理器 GridLayout</h2><p>网格式布局管理器 GridLayout 提供的页面布局规则是将容器的空间划分为若干行与类的网格形式，每个网格称为是单元格，在容器上添加组件是时，他们会按照从左到右，从上到下的顺序在网格中排列。 </p>
<p>网格的行数和列数可以在构造方法里面指定。</p>
<p>利用 GridLayout 布局策略时，容器中每个组件占用一个单元格，所以各组件的宽度相同，同样，所有组件的高度也是相同的。当容器的尺寸发生变化时，各组件的尺寸不会发生变化，但是各自的尺寸将会发生变化。</p>
<p>###构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GridLayout</span><span class="params">()</span> 创建 一个布局管理器，使用默认值，每行只有一个组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GridLayout</span><span class="params">(<span class="keyword">int</span> rows ,<span class="keyword">int</span> cols)</span> 指定行数列数的网格布局管理器</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GridLayout</span><span class="params">(<span class="keyword">int</span> rows ,<span class="keyword">int</span> cols ,<span class="keyword">int</span> hgap, <span class="keyword">int</span> vgap)</span>指定行数列数，水平间距和垂直间距</span></div></pre></td></tr></table></figure>
<p>常用方法和上述管理器相同，不再赘述</p>
<p>下面是一个简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_10</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> JPanel pen = <span class="keyword">new</span> JPanel();</div><div class="line">	<span class="keyword">static</span> JTextField tf = <span class="keyword">new</span> JTextField(<span class="string">"0. "</span>);</div><div class="line">	<span class="keyword">static</span> JButton[] b = <span class="keyword">new</span> JButton[<span class="number">10</span>];</div><div class="line">	<span class="keyword">static</span> JButton bp ,ba, bs,bm, bd ,be ;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		UI_10 frm = <span class="keyword">new</span> UI_10();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;= <span class="number">9</span> ;i++)</div><div class="line">			b[i] = <span class="keyword">new</span> JButton(<span class="string">""</span>+i);</div><div class="line">		bp = <span class="keyword">new</span> JButton(<span class="string">"."</span>); ba = <span class="keyword">new</span> JButton(<span class="string">"+"</span>);</div><div class="line">		bs = <span class="keyword">new</span> JButton(<span class="string">"-"</span>); bm = <span class="keyword">new</span> JButton(<span class="string">"*"</span>);</div><div class="line">		bd = <span class="keyword">new</span> JButton(<span class="string">"/"</span>); be = <span class="keyword">new</span> JButton(<span class="string">"="</span>);</div><div class="line">		frm.setLayout(<span class="keyword">null</span>);</div><div class="line">		frm.setSize(<span class="number">300</span>,<span class="number">220</span>);</div><div class="line">		frm.setResizable(<span class="keyword">false</span>);</div><div class="line">		GridLayout gl = <span class="keyword">new</span> GridLayout(<span class="number">4</span>, <span class="number">4</span>);</div><div class="line">		pen.setLayout(gl);</div><div class="line">		tf.setBounds(<span class="number">35</span>,<span class="number">15</span>,<span class="number">200</span>,<span class="number">25</span>);</div><div class="line">		pen.setBounds(<span class="number">35</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">120</span>);</div><div class="line">		tf.setBackground(Color.CYAN);</div><div class="line">		tf.setHorizontalAlignment(JTextField.RIGHT);</div><div class="line">		pen.add(b[<span class="number">7</span>]); pen.add(b[<span class="number">8</span>]); pen.add(b[<span class="number">9</span>]); pen.add(bd);</div><div class="line">		pen.add(b[<span class="number">4</span>]); pen.add(b[<span class="number">5</span>]); pen.add(b[<span class="number">6</span>]); pen.add(bm);</div><div class="line">		pen.add(b[<span class="number">1</span>]); pen.add(b[<span class="number">2</span>]); pen.add(b[<span class="number">3</span>]); pen.add(bs);</div><div class="line">		pen.add(b[<span class="number">0</span>]); pen.add(bp); pen.add(be); pen.add(ba);</div><div class="line">		frm.add(tf);</div><div class="line">		frm.add(pen);</div><div class="line">		frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		frm.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="卡片式布局管理器-CardLayout"><a href="#卡片式布局管理器-CardLayout" class="headerlink" title="卡片式布局管理器 CardLayout"></a>卡片式布局管理器 CardLayout</h3><p>卡片式的布局管理器大的布局方式将容器中所有的组件如同堆叠起来的一副扑克牌，每次只能够显示其中的一张。一样</p>
<p>这个被显示的组件将会占据容器的全部空间，利用add()方法往容器中加入组件时每个组件对应一个名字，然后依据这个名字利用CardLayout类提供的方法来控制其他组件是否显示，所有基于CardLayout布局方式是在显示区域内每次只有一个组件是可见的。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CardLayout</span><span class="params">()</span> 创建布局管理器，容器中的对象没有间距</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CardLayout</span><span class="params">( <span class="keyword">int</span> hgap ,<span class="keyword">int</span> vgap)</span> 指定组件与容器边缘的水平间距和垂直间距</span></div></pre></td></tr></table></figure>
<p>###常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Contianer parent)</span> 显示 parent中的第一个组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(Container parent)</span> 显示parent中的第二个组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">privious</span><span class="params">( Container parent)</span> 显示parent的前一个组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">(Container parent)</span> 显示最后一个组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Container parent , String name)</span> 显示指定名称的组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHgap</span><span class="params">(<span class="keyword">int</span> hgap)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVgap</span><span class="params">(<span class="keyword">int</span> vgap)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLayoutComponent</span><span class="params">(Component comp)</span></span></div></pre></td></tr></table></figure>
<p>一个简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> -Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Swing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 简单的图形界面设计（一）]]></title>
      <url>/2017/11/02/SimpleJavaSwing1/</url>
      <content type="html"><![CDATA[<h1 id="Java简单的图形界面设计（一）"><a href="#Java简单的图形界面设计（一）" class="headerlink" title="Java简单的图形界面设计（一）"></a>Java简单的图形界面设计（一）</h1><p>Java图形设计图像界面的主要元素由图形用户界面工具包 Swing 提供。 </p>
<p>包括了界面组件，事件处理模型，图形和图像工具、布局管理器等。它们主要都在 javax.swing 包内。 Swing 是Java标准包的一部分，它为大规模的GUI界面开发提供了丰富的基础结构。 </p>
<a id="more"></a>
<h2 id="Swing-组件的简单分类"><a href="#Swing-组件的简单分类" class="headerlink" title="Swing 组件的简单分类"></a>Swing 组件的简单分类</h2><p>Java 语言中构成 GUI 的元素可以称为是组件（Component）。构建GUI的类可以分为三类：</p>
<ol>
<li>容器类 Container </li>
<li>组件类 Component </li>
<li>辅助类 Helper</li>
</ol>
<h4 id="容器类："><a href="#容器类：" class="headerlink" title="容器类："></a>容器类：</h4><p>这里的容器类指的是容器类的组件。 是可以用来包含其他组件的类。</p>
<p>容器类可以分成 顶层容器和非顶层容器。</p>
<p>顶层容器类可以独立的存在。而且大都含有边框，可以移动、放大、缩小、关闭的功能性较强的容器</p>
<p> Java中的顶层容器主要有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JFrame</div><div class="line">JApplet</div><div class="line">JDialog</div></pre></td></tr></table></figure>
<p>非顶层容器不能够单独的存在。它们必须放入窗口之内才可以显示。并且可以拥有自己的布局管理器。</p>
<p>Java中的非顶层容器有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JPanel</div><div class="line">JScrollPane</div><div class="line">JToolBar</div></pre></td></tr></table></figure>
<h4 id="组件类"><a href="#组件类" class="headerlink" title="组件类"></a>组件类</h4><p>Component 类是所有组件类的父类，（顶层容器除外）</p>
<p>所有的 Swing GUI 组件类都是抽象类 JComponent 类的子类。（顶层容器除外）</p>
<p>具体组件类的大致结构在后文会有介绍。</p>
<h4 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h4><p>辅助类是有用来描述组件的属性的，例如有： 绘图类（Graphics )颜色类（Color）字体类（Font）字体属性类（FontMetrics）布局管理器类（LayoutManager）.</p>
<p>需要注意的是，辅助类不是 Component的子类，通常包含在 java.awt 包中。</p>
<h2 id="Swing-容器的层次关系"><a href="#Swing-容器的层次关系" class="headerlink" title="Swing 容器的层次关系"></a>Swing 容器的层次关系</h2><p>一般的 Swing 窗口实际上包括了多个层次，各个此处呢个分别是：</p>
<ol>
<li>顶层容器 ：JFrame</li>
<li>根窗格</li>
<li>分层窗格</li>
<li>内容窗格</li>
<li>玻璃窗格</li>
</ol>
<h4 id="顶层容器-Top-Lever-Container"><a href="#顶层容器-Top-Lever-Container" class="headerlink" title="顶层容器 Top Lever Container"></a>顶层容器 Top Lever Container</h4><p>顶层容器是一个窗口容器对象，该对象中包含了 Swing窗口中的各个层次。</p>
<p>在该对象里可以加入其他的窗口对象。常见的顶层容器有 ： JFrame , JApplet ,JDialog 等</p>
<h4 id="根窗格-Root-Pane"><a href="#根窗格-Root-Pane" class="headerlink" title="根窗格 Root Pane"></a>根窗格 Root Pane</h4><p>根窗格是在创建顶层的容器后自动创建的 ，供 Swing 顶层容器在后台使用。它是顶层容器中包含的最内层。通常无法在这一层上做任何的操作和处理。</p>
<h4 id="分层窗格-Layered-Pane"><a href="#分层窗格-Layered-Pane" class="headerlink" title="分层窗格 Layered Pane"></a>分层窗格 Layered Pane</h4><p>分层窗格中的组件可以设置其图层层次，而且不会被内容窗格中的对象屏蔽。</p>
<p>在分层窗格中的对象还可以设置其层次高低，层次较高的对象和层次较低的对象重叠是，层次低的会被屏蔽。这一层主要用来管理<strong>菜单栏和内容窗格</strong>，菜单栏时可选的。若没有内容，窗格就会充满整个顶层窗格</p>
<h4 id="内容窗格-Content-Pane"><a href="#内容窗格-Content-Pane" class="headerlink" title="内容窗格 Content Pane"></a>内容窗格 Content Pane</h4><p>内容窗格是 Container 类的一个实例，默认状态下是一个具有 <code>BorderLayout</code>布局管理器的 JPanel 对象，大部分的可见组件都可以放在其中，想要获取 JFrame 或者是 JApplet 中的内容窗格，使用 <code>getContentPane()</code>方法来获取。然后使用<code>add()</code>方法将内容加入到这一个层次中。</p>
<h4 id="玻璃窗格"><a href="#玻璃窗格" class="headerlink" title="玻璃窗格"></a>玻璃窗格</h4><p>玻璃窗格主要是用来产生绘图效果，以及触发程序的各种事件，玻璃窗格浮在最上面，默然情况下是隐藏的，如果玻璃窗格可见，那么，它就像是放在根窗格所有其他部分上的一块玻璃，除非实现玻璃窗格的 <code>paint()</code>方法做一些事情。否则它是完全透明的。</p>
<p>####一般来说，根窗格，分层窗格，玻璃窗格都不会直接使用。</p>
<h1 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h1><p>##框架类</p>
<p>主要以 <code>JFrame</code>作为介绍对象，而在图形化界面中，它是作为典型而且用的最多的顶层容器。</p>
<h3 id="JFrame-的主要特点"><a href="#JFrame-的主要特点" class="headerlink" title="JFrame 的主要特点"></a>JFrame 的主要特点</h3><ol>
<li><p>JFrame 类的内容窗格可以利用 getContentPane() 获取 的 Container 类的对象。</p>
</li>
<li><p>JFrame 的显示效果是一个’窗口’,带有标题栏和最小化最大化图标。</p>
</li>
<li><p>可以设置框架的图标，取代标题栏中默认的图标。使用的时候可以使用<code>IconImage</code>类获取一个图标，然后使用JFrame的<code>setIconImage()</code>方法设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Image iconImage = (<span class="keyword">new</span> ImageIcon(fileName)).getImage();</div><div class="line">jfm.setIconImage(iconImage);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>可以选择是否显示 <code>JMenuBar</code>菜单栏。</p>
</li>
<li><p>JFrame 默认初始化是不可见的，使用<code>setVisible(true)</code>方法设置为可见。</p>
</li>
<li><p>默认的布局管理器是 BoderLayout ,可以使用<code>setLayout()</code>方法改变其默认的布局。</p>
</li>
</ol>
<h3 id="JFrame的常用方法"><a href="#JFrame的常用方法" class="headerlink" title="JFrame的常用方法"></a>JFrame的常用方法</h3><p>Swing中的各个组件都有着来自父类或者自身扩展的相当多的方法，在此只列举出一些较为常用的方法，如果想要查看更为具体的内容，请查看官方文档。</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JFrame</span><span class="params">()</span> <span class="comment">//创建一个没有标题的窗口</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JFrame</span><span class="params">(String title)</span> <span class="comment">//创建一个名为 title 的窗口</span></span></div></pre></td></tr></table></figure>
<p>####常用的方法</p>
<p>JFrame的常用方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Container <span class="title">getContentPane</span><span class="params">()</span> <span class="comment">//返回窗口内容窗格</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultCloseOperation</span><span class="params">()</span> <span class="comment">//返回单击窗口上的关闭按钮时执行的操作</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultCloseOperation</span><span class="params">(<span class="keyword">int</span> operation)</span> <span class="comment">//设置默认关闭操作</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIconImage</span><span class="params">(Image icon)</span><span class="comment">//设置窗口图标显示的图像</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJMenuBar</span><span class="params">(JMenuBar jmb)</span><span class="comment">//设置窗口的菜单栏</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> JMenuBar <span class="title">getMenuBar</span><span class="params">()</span><span class="comment">//返回窗口的菜单栏</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Graphics <span class="title">getGraphics</span><span class="params">()</span> <span class="comment">//为窗口创建一个画笔</span></span></div></pre></td></tr></table></figure>
<p>JFrame 继承自 Frame 类的常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span><span class="comment">//设置修改窗口的标题</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span></span>;<span class="comment">//返回窗口的标题</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Color c)</span> <span class="comment">//设置窗口的背景颜色</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent mc)</span><span class="comment">//从窗口删除给定的数据项</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResizable</span><span class="params">(<span class="keyword">boolean</span> resizable)</span><span class="comment">//设置窗口大小是否可以改变</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isResizable</span><span class="params">()</span><span class="comment">//判断窗口是否可以改变大小</span></span></div></pre></td></tr></table></figure>
<p>JFrame 继承自 Container 的常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">add</span><span class="params">(Component comp )</span> <span class="comment">//在容器中添加一个组件</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayout</span> <span class="params">(LayoutManager mgr)</span> <span class="comment">//设置容器组件使用 mgr页面布局</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font f)</span> <span class="comment">//设置容器组件的字体</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component comp)</span> <span class="comment">//删除容器组件中指定的组件</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span><span class="comment">//重绘容器组件</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponents</span><span class="params">(Graphics g)</span> <span class="comment">//重绘容器组件中的所有组件</span></span></div></pre></td></tr></table></figure>
<p>JFrame 继承自 组件类的常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">add</span><span class="params">(Component comp )</span><span class="comment">//容器中添加一个组件 comp</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayout</span><span class="params">(LayoutManager mgr)</span><span class="comment">//设置布局管理器</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font f)</span><span class="comment">//设置组件的字体</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color c)</span><span class="comment">//设置前景色 </span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Color c)</span><span class="comment">//设置背景色</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisible</span><span class="params">(<span class="keyword">boolean</span> b)</span><span class="comment">//设置组件是否显示</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//设置组件显示位置的左上角坐标</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> <span class="comment">//返回对象的名称。</span></span></div></pre></td></tr></table></figure>
<p> 以上详细的列出了JFrame类常用的到的所有方法。之后的组件中只会介绍部分常用的方法，不会区分是子类还是父类方法，具体的情况可以查询API.</p>
<h4 id="一个简单的实例："><a href="#一个简单的实例：" class="headerlink" title="一个简单的实例："></a>一个简单的实例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_1</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> JFrame jfrm = <span class="keyword">new</span> JFrame();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		JLabel lab = <span class="keyword">new</span> JLabel(<span class="string">"this is a Label"</span>);</div><div class="line">		jfrm.setSize(<span class="number">250</span>, <span class="number">140</span>);</div><div class="line">		<span class="comment">//注意这个地方： 我们将 jfrm 设置为Yellow</span></div><div class="line">		jfrm.setBackground(Color.YELLOW);</div><div class="line">		jfrm.setLocation(<span class="number">260</span>, <span class="number">150</span>);</div><div class="line">		jfrm.add(lab);</div><div class="line">		jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		jfrm.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后的结果如图：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui1.png" alt="ui1"></p>
<p>我们可以注意到的是，我们将JFrame的背景设置为了 Color.YELLOW,但是我们并没有看到有相应的设置出现。主要是因为我们设置的是JFrame的背景颜色，而JFrame中包含着一个 内容窗格，将 JFrame 的覆盖了，因此我们可以将它的内容窗格的背景设置成我们想要的颜色，就可以看到了显示的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Container c = jfrm.getContentPane();</div><div class="line">c.setBackground(Color.YELLOW);</div></pre></td></tr></table></figure>
<p>这样就可以看到黄色的界面了。</p>
<h2 id="面板类-JPanel"><a href="#面板类-JPanel" class="headerlink" title="面板类 JPanel"></a>面板类 JPanel</h2><p>面板是一种没有标题栏，没有边框的中间层容器。面板在Swing类中定义，使用JPanel类实现。</p>
<p>面板不是顶层容器，必须放到其他的容器里。</p>
<p>在默认的情况下，面板是透明的，但是可以调用<code>JComponent</code>包中的setOpaque(true)方法将其设置为不透明。若面板透明，就没有背景。这样就会让位于面板下面的组合显示出来。</p>
<p>进行界面设计的时候，通常会将界面分成若干个区域，每个区域使用一个面板，将所有的组件分别放在不同的面板之中，在使用 add() 方法将这些面板加入到顶层窗口的内容窗格中，这样做的好处是<strong>让窗口内容结构化，有利于管理更换调试</strong></p>
<h3 id="JPanel类的特点："><a href="#JPanel类的特点：" class="headerlink" title="JPanel类的特点："></a>JPanel类的特点：</h3><ol>
<li>JPanel 不是顶层容器。必须放入其他容器内。</li>
</ol>
<ol>
<li>JPanel 是一个容器，可以容纳其他的组件，经常用于布局和定位。</li>
<li>默认的LayoutManager是 FlowLayout .</li>
<li>JPanel 可以采用和包含它的容器不同个布局管理器。</li>
<li>是JComponent 的子类，支持双缓冲技术，可以消除闪烁。</li>
</ol>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JPanel</span><span class="params">()</span> <span class="comment">//</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JPanel</span> <span class="params">(LayoutManager layout)</span><span class="comment">//以Layout 为布局管理器创建对象</span></span></div></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span><span class="comment">//设置组件的前景色</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Color bg)</span><span class="comment">//设置组件的背景色</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font f)</span><span class="comment">//设置组件的字体颜色</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestFocusInWindow</span><span class="params">()</span><span class="comment">//请求组件获得焦点</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span><span class="comment">//设置组件是否禁用</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToolTipText</span><span class="params">(String text)</span><span class="comment">//设置光标悬停在组件上显示的文本</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorder</span><span class="params">(Border b)</span><span class="comment">//设置组件的边框</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOpaque</span><span class="params">(<span class="keyword">boolean</span> isOpaque)</span><span class="comment">//设置组件是否透明 true 不透明</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisible</span><span class="params">(<span class="keyword">boolean</span> aFLag)</span><span class="comment">//设置组件是否可见</span></span></div></pre></td></tr></table></figure>
<p>简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"><span class="keyword">import</span> javax.swing.border.TitledBorder;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		JFrame jfrm = <span class="keyword">new</span> JFrame(<span class="string">"MY FRAME"</span>);</div><div class="line">		jfrm.setSize(<span class="number">210</span>, <span class="number">180</span>);</div><div class="line">		jfrm.setLocation(<span class="number">500</span>, <span class="number">400</span>);</div><div class="line">		JPanel jp = <span class="keyword">new</span> JPanel();</div><div class="line">		jp.setSize(<span class="number">120</span>,<span class="number">90</span>);</div><div class="line">		jp.setLocation(<span class="number">40</span>, <span class="number">30</span>);</div><div class="line">		JButton jb = <span class="keyword">new</span> JButton(<span class="string">"Click me"</span>);</div><div class="line">		jb.setSize(<span class="number">80</span>,<span class="number">20</span>);</div><div class="line">		jb.setLocation(<span class="number">20</span>, <span class="number">30</span>);</div><div class="line">		jfrm.setLayout(<span class="keyword">null</span>);</div><div class="line">		jp.setLayout(<span class="keyword">null</span>);</div><div class="line">		jp.add(jb);</div><div class="line">		jp.setBorder(<span class="keyword">new</span> TitledBorder(<span class="string">"Panel Area"</span>));</div><div class="line">		jfrm.add(jp);</div><div class="line">		jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		jfrm.setVisible(<span class="keyword">true</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui2.png" alt="ui2"></p>
<h1 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h1><h2 id="标签-JLabel"><a href="#标签-JLabel" class="headerlink" title="标签 JLabel"></a>标签 JLabel</h2><p> 标签是用来在窗口中显示文字后者图像的控件。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JLabel</span><span class="params">()</span> <span class="comment">//创建 一个没有文字和图像的标签</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JLabel</span><span class="params">(String text)</span><span class="comment">//text为标签上的文字</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JLabel</span><span class="params">(Icon image)</span><span class="comment">//以image为图像创建标签对象</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JLabel</span><span class="params">(String text , <span class="keyword">int</span> horizontalAlignment)</span><span class="comment">//创建指定水平对齐国方式的标签</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JLabel</span><span class="params">(Icon image,<span class="keyword">int</span> horizontalAligment)</span><span class="comment">//同上</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JLabel</span><span class="params">(String text ,Icon image, <span class="keyword">int</span> horizontalAligment)</span><span class="comment">//</span></span></div></pre></td></tr></table></figure>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span><span class="comment">//设置标签上的 text</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon image)</span><span class="comment">//同上</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisabledIcon</span><span class="params">(Icon disabledIcon)</span><span class="comment">//设置标签被禁用时的图标</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHorizontalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span><span class="comment">//设置水平对齐方式</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVerticalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span><span class="comment">//设置垂直对齐方式</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHorizontalTextPosition</span><span class="params">(<span class="keyword">int</span> textPosition)</span><span class="comment">//设置文字和图标之间的水平对齐方式</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVerticalTextPosition</span><span class="params">(<span class="keyword">int</span> textPosition)</span><span class="comment">//设置文字和图标之间的垂直对齐方式。</span></span></div></pre></td></tr></table></figure>
<p>一个简单的示例；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_3</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		JFrame jfrm = <span class="keyword">new</span> JFrame(<span class="string">"Label Practice"</span>);</div><div class="line">		JLabel jlab = <span class="keyword">new</span> JLabel(<span class="string">"This is a Label"</span>,JLabel.CENTER);</div><div class="line">		jfrm.setLayout(<span class="keyword">null</span>);</div><div class="line">		jfrm.setSize(<span class="number">300</span>, <span class="number">200</span>);</div><div class="line">		<span class="comment">//设置背景颜色</span></div><div class="line">		jfrm.getContentPane().setBackground(Color.PINK);</div><div class="line">		<span class="comment">//设置标签不透明</span></div><div class="line">		jlab.setOpaque(<span class="keyword">true</span>);</div><div class="line">		jlab.setBackground(Color.YELLOW);</div><div class="line">		jlab.setForeground(Color.RED);</div><div class="line">		jlab.setLocation(<span class="number">80</span>,<span class="number">60</span>);</div><div class="line">		jlab.setSize(<span class="number">130</span>,<span class="number">30</span>);</div><div class="line">		Font fnt = <span class="keyword">new</span> Font(<span class="string">"Serief"</span>,Font.BOLD+Font.ITALIC,<span class="number">20</span>);<span class="comment">//创建字体对象</span></div><div class="line">		jlab.setFont(fnt);</div><div class="line">		jfrm.add(jlab);</div><div class="line">		jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		jfrm.setVisible(<span class="keyword">true</span>);</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui3.png" alt="ui3"></p>
<h2 id="按钮类"><a href="#按钮类" class="headerlink" title="按钮类"></a>按钮类</h2><h3 id="1-命令按钮-JButton"><a href="#1-命令按钮-JButton" class="headerlink" title="1. 命令按钮 JButton"></a>1. 命令按钮 JButton</h3><p>命令按钮是窗口中最为常用的控件之一。用户可以用鼠标单击它 来控制程序运行的流程。按钮类经过创建之后，通过容器的 add() 方法加入到容器中。</p>
<p>按钮类的大部分方法都是从 javax.swing.AbstractButton类中继承过来的。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JButton</span><span class="params">()</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JButton</span><span class="params">(String label)</span> 创建一个带有label文字的按钮</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JButton</span> <span class="params">(Icon image)</span> 创建一个带有图标的按钮</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JButton</span><span class="params">(String label ,Icon image)</span></span></div></pre></td></tr></table></figure>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doclick</span><span class="params">()</span> 仿真用户点击按钮的操作，以编程的方式点击按钮</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon defaultIcon)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Icon <span class="title">getIcon</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisabledIcon</span><span class="params">(Icon disableIcon )</span> 返回按钮被禁用时的图标</span></div><div class="line"><span class="function"><span class="keyword">public</span> Icon <span class="title">getDisabledIcon</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelected</span><span class="params">()</span> 设置按钮是否被选中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMnemonic</span><span class="params">(<span class="keyword">int</span> mnemonic)</span> 设置按钮的热键</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span> 返回按钮是否被选中</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getActionCommand</span><span class="params">()</span> 返回此按钮的动作命令</span></div><div class="line"><span class="function"><span class="keyword">public</span> Icon <span class="title">getPressedIcon</span><span class="params">()</span> 返回按钮被按下时的图标</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPressedIcon</span><span class="params">(Icon pressedIcon)</span> 设置按钮被按下时的图标</span></div><div class="line"><span class="function"><span class="keyword">public</span> Icon <span class="title">getRolloverIcon</span><span class="params">()</span> 返回鼠标经过时，按钮的图标</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRolloverIcon</span><span class="params">(Icon pressedIcon)</span> 设置鼠标经过时，按钮的图标</span></div></pre></td></tr></table></figure>
<p>一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_4</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		UI_4  ui4 =<span class="keyword">new</span> UI_4();</div><div class="line">		ui4.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		JButton btn = <span class="keyword">new</span> JButton(<span class="string">"A Button"</span>);</div><div class="line">		ui4.setLayout(<span class="keyword">null</span>);</div><div class="line">		ui4.setSize(<span class="number">200</span>,<span class="number">180</span>);</div><div class="line">		ui4.setTitle(<span class="string">"Button practice"</span>);</div><div class="line">		btn.setBounds(<span class="number">50</span>,<span class="number">45</span>,<span class="number">100</span>,<span class="number">40</span>);</div><div class="line">		btn.setToolTipText(<span class="string">"This is a Button "</span>);</div><div class="line">		ui4.add(btn);</div><div class="line">		ui4.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui4.png" alt="ui4"></p>
<h3 id="复选框-JCheckBox和单选框-JRadioButton"><a href="#复选框-JCheckBox和单选框-JRadioButton" class="headerlink" title="复选框 JCheckBox和单选框 JRadioButton"></a>复选框 JCheckBox和单选框 JRadioButton</h3><p>复选框是提供给用户用于选择多个项目的组件,单选框则是只能够选择一个项目的组件。用户可以通过鼠标单击来设置其状态为选中或者是非选中。</p>
<p>需要注意的是，复选框 JCheckBox可以单独使用，但是JRadioButton 在使用时不必须保证按钮在一个ButtonGroup 组中，才能够使多个单选按钮产生一种互斥状态，从而实现在Group内的单选操作。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JCheckBox</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JCheckBox</span><span class="params">(String text)</span> 创建一个以text为文字，初始状态未选中的复选框</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JCheckBox</span><span class="params">(Icon image)</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JCheckBox</span><span class="params">(String text , <span class="keyword">boolean</span> selected)</span> 创建已经选中的复选框</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JCheckBox</span><span class="params">(Icon image , <span class="keyword">boolean</span> selected)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JCheckBox</span><span class="params">(String text,Icon image ,<span class="keyword">boolean</span> selected)</span></span></div></pre></td></tr></table></figure>
<p>单选框的构造方法类似，不再给出</p>
<p>一个简单的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_5</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</div><div class="line">	<span class="keyword">static</span> JFrame frm = <span class="keyword">new</span> JFrame(<span class="string">"CheckBox and RadioButton"</span>);</div><div class="line">    <span class="keyword">static</span> JCheckBox  jb1 = <span class="keyword">new</span> JCheckBox(<span class="string">"黑体"</span>,<span class="keyword">true</span>);</div><div class="line">	<span class="keyword">static</span> JCheckBox  jb2 = <span class="keyword">new</span> JCheckBox(<span class="string">"斜体"</span>);</div><div class="line">	<span class="keyword">static</span> JCheckBox  jb3 = <span class="keyword">new</span> JCheckBox(<span class="string">"下划线"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> JRadioButton jrb1 = <span class="keyword">new</span> JRadioButton(<span class="string">"蓝色"</span>);</div><div class="line">	<span class="keyword">static</span> JRadioButton jrb2 = <span class="keyword">new</span> JRadioButton(<span class="string">"绿色"</span>,<span class="keyword">true</span>);</div><div class="line">	<span class="keyword">static</span> JRadioButton jrb3 = <span class="keyword">new</span> JRadioButton(<span class="string">"红色"</span>);</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ButtonGroup bg =  <span class="keyword">new</span> ButtonGroup();</div><div class="line">		frm.setLocation(<span class="number">200</span>, <span class="number">150</span>);</div><div class="line">		frm.setSize(<span class="number">300</span>, <span class="number">220</span>);</div><div class="line">		frm.setSize(<span class="number">300</span>, <span class="number">220</span>);</div><div class="line">		frm.setLayout(<span class="keyword">null</span>);</div><div class="line">		jb1.setBounds(<span class="number">20</span>,<span class="number">20</span>,<span class="number">150</span>,<span class="number">20</span>);</div><div class="line">		jb2.setBounds(<span class="number">20</span>,<span class="number">40</span>,<span class="number">150</span>,<span class="number">20</span>);</div><div class="line">		jb3.setBounds(<span class="number">20</span>,<span class="number">60</span>,<span class="number">150</span>,<span class="number">20</span>);</div><div class="line">		</div><div class="line">		jrb1.setBounds(<span class="number">20</span>,<span class="number">80</span>,<span class="number">150</span>,<span class="number">20</span>);</div><div class="line">		jrb2.setBounds(<span class="number">20</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">20</span>);</div><div class="line">		jrb3.setBounds(<span class="number">20</span>,<span class="number">120</span>,<span class="number">150</span>,<span class="number">20</span>);</div><div class="line">		bg.add(jrb1);</div><div class="line">		bg.add(jrb2);</div><div class="line">		bg.add(jrb3);</div><div class="line">		frm.add(jb1);</div><div class="line">		frm.add(jb2);</div><div class="line">		frm.add(jb3);</div><div class="line">		frm.add(jrb1);</div><div class="line">		frm.add(jrb2);</div><div class="line">		frm.add(jrb3);</div><div class="line">		frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		frm.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui5.png" alt="ui5"></p>
<h2 id="文本编辑组件"><a href="#文本编辑组件" class="headerlink" title="文本编辑组件"></a>文本编辑组件</h2><p>文本编辑组件是可以接受用户的文本输入并且具有一定的编辑功能的界面元素。这些编辑功能包括修改，删除，复制，粘贴。</p>
<p>JPasswordField 是 JTextField 的子类，JTextField 和JTextArea 是JTextComponent的子类。它们使用的方法多继承自其父类或者祖先类。</p>
<p>JComponent 常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String t)</span> 设置组件中的文本为 t</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span>   获取组件中包含的文本</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">(<span class="keyword">int</span> offs,<span class="keyword">int</span> len )</span> 返回文本组件中以 offs位置开始长度为 len 的文本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> selectionStart,<span class="keyword">int</span> selectionEnd)</span> 返回位置为start和End之间的文本。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span> 选择文本组件内的所有文本</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSelectAll</span><span class="params">()</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelectionColor</span><span class="params">(Color c)</span> 设置被选中的文本颜色为c</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisabledTextColor</span><span class="params">(Color c)</span> 设置禁用时文本的颜色</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEditable</span><span class="params">(<span class="keyword">boolean</span> b)</span> 设置组件是否可以编辑</span></div></pre></td></tr></table></figure>
<h3 id="JTextField"><a href="#JTextField" class="headerlink" title="JTextField"></a>JTextField</h3><p>单行的文本编辑组件，又称为是文本行。也称为文本框。只有一行文本，文本内容超过了文本行的宽度也不会被折行。是一个能够接受用户键盘输入的文本编辑组件。</p>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextField</span><span class="params">()</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextField</span><span class="params">(<span class="keyword">int</span> columns)</span> 创建文本框，设置文本框的宽度可以容纳的最大字符数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextField</span><span class="params">(String text)</span> 创建text为默认文本的文本框</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextField</span><span class="params">(String text, <span class="keyword">int</span> columns )</span></span></div></pre></td></tr></table></figure>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> 返回文本框的宽度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColumns</span><span class="params">(<span class="keyword">int</span> columns)</span> 设置文本框的宽度为 columns 字符</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHorizontalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span> 设置文本框的水平对齐方式</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHorizontalAlignment</span><span class="params">()</span> 返回文本的水平对齐方式</span></div></pre></td></tr></table></figure>
<h3 id="JPasswordField"><a href="#JPasswordField" class="headerlink" title="JPasswordField"></a>JPasswordField</h3><p>密码文本框组件。具有文本行的所有功能，只是在其中输入字符的时候，字符可能够会被显示成其他的符号。</p>
<p>它的构造方法和 JTextField 基本相同在此不再给出</p>
<h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getEchoChar</span><span class="params">()</span> 返回回显的字符 默认值为 "*"</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEchoChar</span><span class="params">(<span class="keyword">char</span> c)</span> 设置密码文本组件的回显字符</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">getPassword</span><span class="params">()</span> 返回密码文本行组件中所包含的文本</span></div></pre></td></tr></table></figure>
<h3 id="JTextArea和滑动窗格-JScrollPane"><a href="#JTextArea和滑动窗格-JScrollPane" class="headerlink" title="JTextArea和滑动窗格 JScrollPane"></a>JTextArea和滑动窗格 JScrollPane</h3><p>可以实现多行文本的输入，还可以判断是否折行,由于文本框实际上是多行的字符，因为文本行只能够输入一行文字，所以在需要输入和显示过多的文字的时候，可以使用文本区。文本区中显示的行数和列数都可能超出文本区的范围。可以将文本区放入滑动窗格中， 实现滚动功能。使用滑动窗格的组件还有 JList,JTable,JTree等，应用滑动窗格非常简单，只需要创建一个JScrollPane 对象，为其指定一个要显示的组件即可。</p>
<p>####构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextArea</span><span class="params">()</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextArea</span><span class="params">(<span class="keyword">int</span> rows ,<span class="keyword">int</span> cols)</span> 指定文本区中的行数和列数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextArea</span><span class="params">(String text)</span> 默认文本为 text</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTextArea</span><span class="params">(String text , <span class="keyword">int</span> rows ,<span class="keyword">int</span> cols)</span></span></div></pre></td></tr></table></figure>
<h4 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String str)</span> 将文本最加到文本区中文件的末尾</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceRange</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> 将strat 到end的文本用 str代替</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRows</span><span class="params">(<span class="keyword">int</span> rows)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColumns</span><span class="params">(<span class="keyword">int</span> cols)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLineWrap</span><span class="params">(<span class="keyword">boolean</span> wrap )</span> wrap为<span class="keyword">true</span>时，当行的长度大于文本区的宽度时，将换行，若为<span class="keyword">false</span>则不换行，默认为 <span class="keyword">false</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWrapStyleWord</span><span class="params">(<span class="keyword">boolean</span> word)</span> word 为<span class="keyword">true</span> ,当行的长度大于文本区的宽度时超长部分会换行，若为 <span class="keyword">false</span> 则超长部分会被折断</span></div></pre></td></tr></table></figure>
<p>一个简单的实例使用文本组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_6</span>  <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</div><div class="line"></div><div class="line">	JTextField jtf = <span class="keyword">new</span> JTextField(<span class="string">"不可用"</span>);</div><div class="line">	<span class="keyword">static</span> JPasswordField jpf = <span class="keyword">new</span> JPasswordField(<span class="string">"zero"</span>,<span class="number">30</span>);</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UI_6</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(str);</div><div class="line">		jtf.setBounds(<span class="number">20</span>,<span class="number">40</span>,<span class="number">140</span>,<span class="number">20</span>);</div><div class="line">		jtf.setEditable(<span class="keyword">false</span>);</div><div class="line">		add(jtf);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		UI_6 ui6 = <span class="keyword">new</span> UI_6(<span class="string">"文本编辑组件练习"</span>);</div><div class="line">		JTextArea jta = <span class="keyword">new</span> JTextArea(<span class="string">"Hello"</span>,<span class="number">10</span>,<span class="number">30</span>);</div><div class="line">		JScrollPane jsp =  <span class="keyword">new</span> JScrollPane(jta);</div><div class="line">		ui6.setLocation(<span class="number">200</span>,<span class="number">150</span>);</div><div class="line">		ui6.setSize(<span class="number">240</span>,<span class="number">220</span>);</div><div class="line">		ui6.setLayout(<span class="keyword">null</span>);</div><div class="line">		jsp.setBounds(<span class="number">20</span>,<span class="number">70</span>,<span class="number">160</span>,<span class="number">100</span>);</div><div class="line">		jpf.setBounds(<span class="number">20</span>,<span class="number">10</span>,<span class="number">140</span>,<span class="number">20</span>);</div><div class="line">		ui6.add(jpf);</div><div class="line">		ui6.add(jsp);</div><div class="line">		<span class="keyword">char</span>[] password = jpf.getPassword();</div><div class="line">		String str = <span class="keyword">new</span> String(password);</div><div class="line">		System.out.println(<span class="string">"Password:"</span> +password+<span class="string">"转换为文本后："</span>+str);</div><div class="line">		ui6.setVisible(<span class="keyword">true</span>);</div><div class="line">		ui6.setResizable(<span class="keyword">false</span>);</div><div class="line">		ui6.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui6.png" alt="ui6"></p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui6_1.png" alt="ui6_1"></p>
<h2 id="选项卡窗格-JTabbedPane"><a href="#选项卡窗格-JTabbedPane" class="headerlink" title="选项卡窗格 JTabbedPane"></a>选项卡窗格 JTabbedPane</h2><p>选项卡在Swing中使用 JTabbledPane类来实现，选项卡窗格允许包括多个选项卡，可以把多个不同的组件放在不同的选项卡中，选项卡窗格被创建之后，我们通常需要添加到布局好的窗口后者面板中，通常我们可以添加到一个布局为1X1的网格布局或者是边界布局中，选项课窗格的每个选项卡都可以容纳一个JPanel作为子组件。用户只需要设计好并且添加到选项卡里面即可。</p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTabbedPane</span><span class="params">()</span> </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTabbedPane</span><span class="params">(<span class="keyword">int</span> tabPlacement)</span> 创建一个空的选项卡窗格对象，tabPlacement表示标题显示参数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JTabbedPane</span><span class="params">(<span class="keyword">int</span> tabPlacement ,<span class="keyword">int</span> tabLayoutPolicy)</span> 同上，tabLayoutPolicy 表示一次运行中不能够放入所有的选项卡时，放置选项卡的策略。</span></div></pre></td></tr></table></figure>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">add</span><span class="params">(Component component)</span> 在选项卡中添加组件，component.<span class="title">getName</span><span class="params">()</span> 返回组件名称</span></div><div class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">add</span><span class="params">(Component component, <span class="keyword">int</span> index)</span> 在指定的选项卡索引位置添加组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">add</span><span class="params">(String title , Component )</span> 添加标题为title的组件 component</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTab</span><span class="params">(String title , Icon icon , Component component)</span> 添加标题为 title,图标为icon 的组件</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitleAt</span><span class="params">(<span class="keyword">int</span> index, String title)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIconAt</span><span class="params">(<span class="keyword">int</span> index, Icon icon)</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToolTipTextAt</span><span class="params">(<span class="keyword">int</span> index, String toolTipText)</span> 将index 位置的工具文本提示设置为 toopTipText</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTabAt</span><span class="params">( <span class="keyword">int</span> index)</span> 删除指定位置的组件</span></div></pre></td></tr></table></figure>
<p>一个简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.swing.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UI_7</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</div><div class="line">	JTabbedPane jtab = <span class="keyword">new</span> JTabbedPane(JTabbedPane.TOP);</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UI_7</span><span class="params">()</span> </span>&#123;</div><div class="line">		JLabel jlab1 = <span class="keyword">new</span> JLabel(<span class="string">"JLabel1"</span>);</div><div class="line">		JLabel jlab2 = <span class="keyword">new</span> JLabel(<span class="string">"JLabel2"</span>);</div><div class="line">		JLabel jlab3 = <span class="keyword">new</span> JLabel(<span class="string">"JLabel3"</span>);</div><div class="line">		JLabel jlab4 = <span class="keyword">new</span> JLabel(<span class="string">"JLabel4"</span>);</div><div class="line">		JLabel jlab5 = <span class="keyword">new</span> JLabel(<span class="string">"JLabel5"</span>);</div><div class="line">		JLabel jlab6 = <span class="keyword">new</span> JLabel(<span class="string">"JLabel6"</span>);</div><div class="line">		jtab.add(<span class="string">"Label1"</span>, jlab1);</div><div class="line">		jtab.add(<span class="string">"Label2"</span>, jlab2);</div><div class="line">		jtab.add(<span class="string">"Label3"</span>, jlab3);</div><div class="line">		jtab.add(<span class="string">"Label4"</span>, jlab4);</div><div class="line">		jtab.add(<span class="string">"Label5"</span>, jlab5);</div><div class="line">		jtab.add(<span class="string">"Label6"</span>, jlab6);</div><div class="line">		<span class="keyword">this</span>.add(jtab);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		UI_7 ui7 = <span class="keyword">new</span> UI_7();</div><div class="line">		ui7.setTitle(<span class="string">"选项卡的应用"</span>);</div><div class="line">		ui7.setSize(<span class="number">500</span>,<span class="number">500</span>);</div><div class="line">		ui7.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line">		ui7.setVisible(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/UI/ui7.png" alt="ui7"></p>
<p><a href="http://elemtype.com/2017/11/03/SimpleJavaSwing2/" target="_blank" rel="external">下一节 布局管理器</a>   </p>
<p>以上演示的源码可在 RESOURCE（幻灯片3）</p>
<p>resource/code/SimpleJavaSwing.zip 处获得。</p>
]]></content>
      
        <categories>
            
            <category> -Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Swing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaThread_1]]></title>
      <url>/2017/11/02/JavaThread-1/</url>
      <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的SQL 命令]]></title>
      <url>/2017/11/02/SQLSimpleIntroductiion/</url>
      <content type="html"><![CDATA[<h1 id="SQL命令"><a href="#SQL命令" class="headerlink" title="SQL命令"></a>SQL命令</h1><p>常用的 SQL 命令。</p>
<a id="more"></a>
<p>所有的 SQL 操作均在 SQL Server 上执行，和 SQL 标准可能有些许的不兼容，更为详细的资料可以查看 W3cSchool的相关文档。</p>
<h2 id="用户操作与数据控制"><a href="#用户操作与数据控制" class="headerlink" title="用户操作与数据控制"></a>用户操作与数据控制</h2><h3 id="使用-SQL-语句创建用户"><a href="#使用-SQL-语句创建用户" class="headerlink" title="使用 SQL 语句创建用户"></a>使用 SQL 语句创建用户</h3><h4 id="1-创建登录名"><a href="#1-创建登录名" class="headerlink" title="1.创建登录名"></a>1.创建登录名</h4><blockquote>
<p>格式： create login <loginname> with password = ‘passwordNumber’ ;</loginname></p>
</blockquote>
<p>其中： LoginName 是用于登录服务器的用户名，PasswordNumber： 是用户名登录的密码。在 SQL Server 服务器的 《安全性》下的《登录名》，可以看到创建的用户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> login  王明 <span class="keyword">with</span> <span class="keyword">password</span> = <span class="string">'123456'</span>;</div><div class="line"><span class="keyword">create</span> login  李刚 <span class="keyword">with</span> <span class="keyword">password</span> = <span class="string">'456789'</span>;</div></pre></td></tr></table></figure>
<h4 id="2-创建数据库用户"><a href="#2-创建数据库用户" class="headerlink" title="2.创建数据库用户"></a>2.创建数据库用户</h4><p>用户登录服务器后，要进入某一个数据库访问，就需要为登录用户在该数据库中建立 一个数据库用户名。</p>
<blockquote>
<p>格式： create user <username> for Login <loginname> ;</loginname></username></p>
</blockquote>
<p>需要注意的是创建数据库用户名之前一定要切换到当前的数据库。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> DateBase1; <span class="comment">--切换到当前用户</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">user</span> 王明 <span class="keyword">for</span> login 王明 ;</div><div class="line"><span class="keyword">create</span> <span class="keyword">user</span> 李刚 <span class="keyword">for</span> login 李刚 ;</div></pre></td></tr></table></figure>
<blockquote>
<p>数据库用户和登录账户名可以不同，但是为了便于记忆，可以设置成相同的名字。</p>
</blockquote>
<h4 id="3-授权"><a href="#3-授权" class="headerlink" title="3.授权"></a>3.授权</h4><p>在数据库中添加新用户之后，新用户没有访问数据库中数据的权限，需要数据库管理人员授予相应的权限后，才能够执行新的操作。</p>
<blockquote>
<p>格式： grant &lt;权限&gt; [,&lt;权限&gt;…] on &lt;对象名&gt; to &lt;用户&gt; [,&lt;用户&gt;..]</p>
<p>[with grant option ];</p>
</blockquote>
<p>注意的是，在SQL  server 中，on 之后只能够有一个类型。</p>
<p><code>with grant option</code>  是一个可选操作，授予权限的时候如果加上了该子句，那么获得权限的用户还可以把权限给予其他的用户。如果没有的话，那么就只能够使用该权限，不能够传播权限。</p>
<p>例如： 授予李刚对ST数据库中Student表的 select 权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> ST;</div><div class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> Student <span class="keyword">to</span> 李刚;</div></pre></td></tr></table></figure>
<p>授予李刚 插入，更新，删除的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> ST;</div><div class="line"><span class="keyword">grant</span> <span class="keyword">insert</span> ,<span class="keyword">update</span>, <span class="keyword">delete</span> <span class="keyword">on</span> Student <span class="keyword">to</span> 李刚 ;</div></pre></td></tr></table></figure>
<h4 id="4-撤销权限"><a href="#4-撤销权限" class="headerlink" title="4. 撤销权限"></a>4. 撤销权限</h4><p>如果不希望用户执行某些对数据库的操作时，可以撤销先前授予用户的操作权限。</p>
<blockquote>
<p>格式： revoke select on &lt;&gt;</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> -DateBase </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Sql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单UML类图绘制]]></title>
      <url>/2017/10/31/ClassDiagram/</url>
      <content type="html"><![CDATA[<h1 id="简单的UML类图绘制"><a href="#简单的UML类图绘制" class="headerlink" title="简单的UML类图绘制"></a>简单的UML类图绘制</h1><p>UML 2.0 的所有图形中，类图（Class diagram）是使用频率最高的UML图之一。至少笔者接触到的所有UML图中，绝大多数都是类图。类图是用于描述系统中包含的类以及他们之间的相互关系，帮助人们简化对系统的理解。也是系统编码和测试的重要依据。本文以 Java 语言为基础，来简述类图的一些简单的绘制方法。</p>
<a id="more"></a>
<blockquote>
<p>需要说明是：本文中引用的部分图片使用eclipse插件生成，一些图标可能和描述的不同，图片仅仅用于演示关键部分。 请以具体说明为准，</p>
</blockquote>
<h2 id="类的UML图示"><a href="#类的UML图示" class="headerlink" title="类的UML图示"></a>类的UML图示</h2><p>我们说，类是封装了数据和行为，是具有相同属性，操作，关系的对象集合的总称。是面向对象的重要组成部分。</p>
<p>UML中，类使用包含 <code>类名``属性``操作</code>的使用带有分隔线的方框来表示。</p>
<p>所以在类图中，类由三部分组成：</p>
<p>1.第一部分是类名，是一个 字符串。</p>
<p>2.第二部分是类的属性（成员变量）一个类可以有任意多个属性，也可以没有属性。</p>
<p>UML中的表示方式：</p>
<blockquote>
<p>​    &lt;可见性&gt; &lt;名称&gt; : &lt;类型&gt; [= 缺省值]</p>
</blockquote>
<p>缺省值是一个可选项，即属性的初始值。</p>
<p>3.第三部分是类的操作，即类的成员方法。</p>
<p>UML中的表示方式：</p>
<blockquote>
<p>  &lt;可见性&gt; &lt;名称&gt;   (参数列表)         [: 返回类型]</p>
</blockquote>
<p>参数列表表示方法的参数，参数的个数是任意的，多个参数之间用逗号隔开。</p>
<p>返回类型是一个可选项，取决于编程语言的实现，可以是基本类型，可以是用户自定义类型，也可以是 （void） 空类型，如果是构造方法，则无返回类型。</p>
<p>##可见性</p>
<p>属性或者操作的可见性定义相同。</p>
<p>可见性表示该属性对于类外的元素而言是否可见(及访问权限)。主要包括：</p>
<p><code>public</code>  <code>private</code>  <code>protected</code>  三种，分别用 <code>+</code>  <code>-</code>  <code>#</code> 表示。</p>
<p>默认包访问权限不用表示。</p>
<h4 id="一个简单的类UML表示："><a href="#一个简单的类UML表示：" class="headerlink" title="一个简单的类UML表示："></a>一个简单的类UML表示：</h4><p>假设有一个类： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name ;</div><div class="line">  	<span class="keyword">private</span> <span class="keyword">int</span> age ;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name ;</div><div class="line">      	 <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">  	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="keyword">this</span>.age= age;  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的UML图可以表示为：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/classdiagram1.png" alt="classdiagram1"></p>
<h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><p>类并不是孤立存在的，类与类之间存在着不同的关系，UML对此提供了不同的表示方法：</p>
<p>##类之间的关系–关联关系</p>
<p>关联关系（Association）用于表示一类对象和另一类对象有联系。在UML类图中，用实线连接关联关系的对象所对应的类UML.</p>
<p>Java，或者c++等编程语言实现关联关系，通常是一个类的对象作为另一个类的成员变量。</p>
<p>UML类图表示关联关系的时候，可以在关联关系上标注角色名（一般使用表示两者之间关系的动词或者名词表示角色名），不是必须的， 但是可以使类与类之间的关系更加的明确。</p>
<p>类如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JFrame</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> JTextArea textArea;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JButton</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>在一个框架 JFrame 中包含了一个文本域 JTextArea 类型的对象。他们两者的关系可以用UML表示为：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram4.png" alt="2"></p>
<p>####关联分为 单向关联和双向关联自关联，多重性关联，聚合关系等。</p>
<p><strong>单向关联</strong>一般来说都是一种包含或者被包含的关系，类似于上文所述的框架中包含了文本域，使用带有箭头的实线表示，箭头指向被包含的类。</p>
<p><strong>双向关联</strong>，默认情况下，关联是双向的，例如顾客买了一堆商品并且拥有了这些上平，而对于商品来说，被卖出去的商品一定和购买它的顾客有联系。</p>
<p>双向关联使用不带箭头的实线表示。</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram5.png" alt="5"></p>
<p><strong>自关联</strong> 在一些系统中，有些累的属性对象可能是自身，这种关联关系就称之为自关联关系。</p>
<p><strong>多重性关联</strong> 表示两个关联对象之间在数量上的对应关系，例如一个框架中可能含有多个文本域，一个顾客买了多个商品。多重关联可以是单向的，也可以是双向的。对象之间可一存在多重的关联关系，常见的关联方式如下表：</p>
<table>
<thead>
<tr>
<th>表示</th>
<th>多重性关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>1..1</td>
<td>表示另一个类的对象只和该类的一个对象有关。</td>
</tr>
<tr>
<td>0…*</td>
<td>表示另一个类的对象只和该类的0个或者多个对象有关。</td>
</tr>
<tr>
<td>1…*</td>
<td>表示另一个类的对象只和该类的一个对象有关。</td>
</tr>
<tr>
<td>0…1</td>
<td>表示另一个类的对象只与该类的0个或者1个对象有关</td>
</tr>
<tr>
<td>m…n</td>
<td>表示另一个类的一个对象，置于该类最少m个，最多n个对象有关</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要个别注意的是，上述的表示形容的是另一个类的对象和本对象的关系。</p>
<p>例如： 一个框架可以有0个或者多个文本域，但是一个文本域只能够属于一个界面，</p>
<p>对框架对象而言，文本域（另一个类的对象）的一个对象只与该框架的一个对象有关系。</p>
<p>对文本域而言，一个框架（另一个类的对象）可以有0个或者多个的文本域，</p>
<p>因此，两者之间的关系可以表示为</p>
</blockquote>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram2.png" alt="3"></p>
<p><strong>聚合关系</strong></p>
<p>聚合关系表示的是整体与部分的关系，即聚合关系中，成员变量是整体对象的一部分。但是，成员变量可以脱离实体而单独存在，在UML聚合关系通常会使用空心菱形的实线表示。例如 ：车轮是汽车的组成部分，车轮又可以单独存在，因此汽车和车轮是聚合关系。空心菱形在聚合者一边（汽车一边）</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram6.png" alt="7"></p>
<p><strong>组合关系</strong></p>
<p>组合关系和聚合关系比较容易混淆，他们也是整体和部分的关系，但是，组合关系中，整体对象可以控制成员对象的生命周期（整体对象不存在，成员变量也就不存在,两者之间存在着明显的共生关系）</p>
<p>就说一个人的头部和人自身就是一种组合关系，人由头部和其他器官组合而成，如果没有人，那么头部也就不复存在。而汽车的轮子则不同，即便是没有汽车，轮子也可以独立的存在。因此，人和头部是一中组合关系，而汽车和轮子是聚合关系。</p>
<p>组合关系使用实心的菱形实线表示，实心菱形在组合者(人)一边.</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram7.png" alt="8"></p>
<h2 id="类之间的关系–依赖关系"><a href="#类之间的关系–依赖关系" class="headerlink" title="类之间的关系–依赖关系"></a>类之间的关系–依赖关系</h2><p>依赖关系是一种使用关系，特定事务的改变可以影响到该事务的其他事物，表示一个事物使用另一个事物时使用一来关系。</p>
<p>绝大多数情况下，依赖关系体现在一个类的方法会使用另一个类作为在参数。</p>
<p>在UML中，使用带箭头的虚线表示一来关系，依赖的一方指向被依赖的一方。</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram8.png" alt="9"></p>
<p>比如一个人想要开车，这个人的 driver(Car car) 方法，就依赖于具体的车的使用方法，比如自动挡或者是手动挡，车的使用方法决定了这个人开车的方式。因此这个人的driver()方法，依赖于车的使用方法。 </p>
<p>在实际的程序中，体现依赖关系的方式大概有这几种：</p>
<p>​    第一种也是最常用的一种方式类似于上述的车和驾车人的关系，就是一个类法方法中需要使用另外一个类的方法或者使用其静态方法。。</p>
<p>​    第二种是在一个类的方法中将另外一个类的对象作为其局部变量。</p>
<h2 id="类之间的关系–继承（泛化）关系"><a href="#类之间的关系–继承（泛化）关系" class="headerlink" title="类之间的关系–继承（泛化）关系"></a>类之间的关系–继承（泛化）关系</h2><p>泛化（Generalization）关系就是继承关系，用于描述子类和父类的关系，父类又被称为是基类或者是超类，具体的细节在类似于Java这样的面向对象语言中已经有了非常详细的描述,不同语言的实现方式有些与不同，类似于Java不支持多重继承，C++支持多重继承之类，可以视具体情况而定。</p>
<p>在UML中，继承关系使用带有空心箭头的实线表示。箭头指向父类。这样做的意义在于，在一个类中，子类一定知道它的父类是谁，而父类不一定知道它的子类是谁。</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/classdiagram10.png" alt="45"></p>
<p>而类图的描述使，一般父类要求带有其拥有的所有属性和操作，而子类只需要表示出和父类不同的扩展内容即可。</p>
<h2 id="类之间的关系–接口与实现关系"><a href="#类之间的关系–接口与实现关系" class="headerlink" title="类之间的关系–接口与实现关系"></a>类之间的关系–接口与实现关系</h2><p>面向对象中引入了接口的概念，它没有属性，所有的操作都是抽象的，只进行声明不做任何的实现。UML中使用和类类似的方法表示接口。理论上将所有的接口名，抽象方法，抽象类，都应该用斜体表示。在java中可以使用&lt;<interface>&gt;表示接口。</interface></p>
<p>接口和实现类之间使用空心箭头的虚线表示，和继承关系一样，箭头指向接口，表示实现类可以知道自己所实现的接口，而接口不一定知道自己的实现类。</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram45.png" alt="67"></p>
<h1 id="书写规则补充"><a href="#书写规则补充" class="headerlink" title="书写规则补充"></a>书写规则补充</h1><p>需要注意的是，在UML类图中，所有的静态成员（操作（方法），属性（成员变量））都要在名称上加下划线。</p>
<p>所有的抽象类，抽象方法，接口，以斜体表示。（Java中表示接口可以在接口名上加&lt;<interface>&gt;表示接口）。</interface></p>
<p>接口的还有一种写法是在接口上添加一个带小圆圈的实线表示。</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram56.png" alt=""></p>
<p>以上的书写规则仅仅适用于书写，如果采用软件生成UML,则生成的图像会有各自不同的表示方法，（大体都一样），使用上述软件的时，要视情况的而定。</p>
<h2 id="UML关系表示中的箭头指向问题。"><a href="#UML关系表示中的箭头指向问题。" class="headerlink" title="UML关系表示中的箭头指向问题。"></a>UML关系表示中的箭头指向问题。</h2><p>在看完以上的示例之后，可能已经对各个关系中箭头谁指向谁的问题搞混了，笔者在学习的时候也被搞的头晕脑胀，但是，如果搞清楚，关系图中的箭头指向的意义，这个问题就非常简单了。</p>
<p>简单来说，在UML中，所有的箭头都是指向能够被确定的一方。</p>
<p>笔者表达能力有限，什么意思呢。</p>
<p>就是说，箭头的方向代表的是可以从一个对象确定另一个对象的意思。</p>
<p>例如： 在单向关联的关系中，一个框架中有几个文本域，从这个框架我们可以知道它持有的是哪个文本域对象，但是对于文本域来说，文本域是没有办法知道它的哪个对象被哪个框架持有的。因此，单项关系中使用实线的箭头，箭头方向指向了文本域，表示通过框架可以确定对应的文本域对象。</p>
<p>在双向关联的关系中，一个人到商店里面买个一商品，对于人来说，他一定确定哪个商品自己买的，对于商品来说，它也是可以确定自己是被那个人买的。如此，它们都可以确定对方的存在，所以使用双向实线箭头来表示这种关系。</p>
<p>在依赖关系中， 我们说一个驾驶员开车的方法依赖于所开的车时自动挡还是手动挡，我们可以理解，驾驶员是可以确定自己开的是哪一辆车的，而从车的角度来看，一辆车是没有办法知道自己将会被那个驾驶员开的。所以表示依赖关系的虚线箭头从驾驶员指向车。</p>
<p>前面我们也已经提到过，继承和接口的表示时，继承使用实线空心箭头指向父类，是因为对于子类来说，它是一定知道自己的父类是谁的，而父类却无法知道自己的子类有哪些。接口也一样，使用虚线实心箭头由实现类指向接口。是因为实现类是可以知道自己实现了那些接口，而接口没有办法确定自己的实现类的。</p>
<p>说完了箭头，再说表示整体与部分关系的聚合关系和组合关系使用菱形实现来表示，菱形所在的一方永远是整体的一方。就像车和车轮之间是聚合关系，一辆车是被车轮和其他的部件组合而成的，而我们知道即使车不存在，车轮也可以单独存在，它们之间没有共生的关系，所以它们是一种聚合关系，使用空心菱形实线表示这种关系，菱形在作为整体的车一方。 同样，人体和头部的关系，人体是由头部和其他部件组成的，但是，我们知道如果人不存在的话，头部也就无法存在，他们之间是一种同生共死的关系，所以是一种组合关系，使用实心菱形实线表示这种关系，菱形在作为整体的人体的一方。 </p>
<p>以上就是关于UML类图中的箭头和菱形所在方向的问题，再次重复一下，箭头永远指向可以被确定的一方，菱形永远在整体的一边。</p>
<p>看到这儿，相信对UML已经有了基本的认识了，那么赶快找一个趁手的工具，实践一下自己的成果吧。</p>
<h3 id="推荐一个生成UML-的eclipse插件"><a href="#推荐一个生成UML-的eclipse插件" class="headerlink" title="推荐一个生成UML 的eclipse插件"></a>推荐一个生成UML 的eclipse插件</h3><p><a href="http://takezoe.github.io/amateras-update-site/" target="_blank" rel="external">Amateras Modeler</a> </p>
<p>一个非常优秀而且简便易用的插件，点击插件名可以进入项目网站，从其中复制URL，使用 eclipse 安装。</p>
<p>具体安装步骤为： eclipse &gt;&gt;help&gt;&gt;install more software&gt;&gt;添加链接搜索下载即可。</p>
<p>当然也可以直接使用下面的URL复制粘贴，不过，由于可能出现更新版本的产品，推荐到官方页面去寻找链接。</p>
<p>URL : <a href="http://takezoe.github.io/amateras-update-site/" target="_blank" rel="external">http://takezoe.github.io/amateras-update-site/</a></p>
<p>！注意在安装Amateras Modeler 之前要先行安装 GEF 插件，该插件可以到<a href="https://www.eclipse.org/" target="_blank" rel="external">eclipse</a>官网的项目（projects）栏目下输入GEF搜索，找到链接以同样的方式下载安装即可。</p>
<p>GEF安装地址： (可能失效)<a href="http://download.eclipse.org/tools/gef/updates/releases" target="_blank" rel="external">http://download.eclipse.org/tools/gef/updates/releases</a></p>
<p>利用Amateras Modeler 生成的一个类图示例：</p>
<p><img src="http://oykemr77k.bkt.clouddn.com/image/elemtype/png/classdiagram.png" alt="345"></p>
]]></content>
      
        <categories>
            
            <category> -Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -uml </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[资源推荐]]></title>
      <url>/2017/10/29/amway/</url>
      <content type="html"><![CDATA[<p>Exciting works! Try to understand them, and will be amazed by their charms.</p>
<a id="more"></a>
<h1 id="ACGN"><a href="#ACGN" class="headerlink" title="ACGN"></a>ACGN</h1><p>### </p>
]]></content>
      
        <categories>
            
            <category> -Other </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -amway </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Words]]></title>
      <url>/2017/10/29/Words/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p>category n. 类别，种类，范畴‘</p>
<p>a time filler 消磨时间的事物</p>
<p>a valuable experience 宝贵的经历</p>
<p>a waste of time and resources 浪费时间和资源。</p>
<p>abandon oneself to 沉溺于</p>
<p>absorb the quintessence 吸收精华</p>
<p>academic pressure 学习压力。</p>
<p>accumulate v. 堆积</p>
<p>addictive a. 上瘾的</p>
<p>advocate v. 提倡</p>
<p>aesthetic a. 美学的</p>
<p>affect v./n. 影响</p>
<p>alluring a. 吸引人的</p>
<p>an example to 是…的榜样</p>
<p>an increasing number of 越来越多的</p>
<p>approach n. 方法</p>
<p>artistic value 艺术价值</p>
<p>as a result 结果</p>
<p>as far as I’m concerned 就我而言</p>
<p>assume responsibility 承担责任</p>
<p>authoritative a. 权威的</p>
<p>available a. 可以获得的</p>
<p>backbone n. 脊骨，支柱，基础</p>
<p>be aware of 意识到</p>
<p>be obsessed with 沉迷于</p>
<p>be out of line with practice 不切实际</p>
<p>be passed done 传递</p>
<p>be related to 与…相关</p>
<p>be wasteful with 浪费</p>
<p>bear the pressure 承受压力</p>
<p>bear … in mind 牢记</p>
<p>build on 建立在…之上</p>
<p>bury v. 埋葬</p>
<p>by means of 通过…的方式</p>
<p>call upon 号召</p>
<p>campus n. 校园</p>
<p>cancel v. 取消</p>
<p>carelessness n. 担心</p>
<p>celebrated a. 著名的</p>
<p>cherish v. 珍视</p>
<p>civilization n. 文明</p>
<p>commercial  n. 商业广告</p>
<p>compare to 于…相比</p>
<p>comprehensive a. 全面的</p>
<p>consequence n. 结果</p>
<p>contribute v. 贡献</p>
<p>cope with 应付</p>
<p>costume n. 服装</p>
<p>course n. 课程</p>
<p>cradle of culture 文化摇篮</p>
<p>cross-talk n. 相声</p>
<p>cultivate v. 培养，养成</p>
<p>damage v. 破坏</p>
<p>damage environment 破坏环境</p>
<p>deal with 处理</p>
<p>degrade v. 降解，降低，降低身份 ，侮辱  [dɪ’ɡreɪd]</p>
<p>depredate v. 掠夺，破坏     [‘deprɪˌdeɪt]</p>
<p>detract v. 转移    [dɪ’trækt]</p>
<p>development of personality 个性发展</p>
<p>discontinue one’s studying 辍学</p>
<p>diversify v. 使多样化    [daɪ’vɜrsɪfaɪ] </p>
<p>efficiency n. 功率，功效</p>
<p>elective n. 选修课</p>
<p>enlarge v. 增长增大</p>
<p>environmental awareness 环保意识</p>
<p>environmental pollution 环境污染</p>
<p>error n. 错误</p>
<p>exam n. 考试</p>
<p>opening time 开馆时间</p>
<p>fail v. 失败</p>
<p>fail to 不能</p>
<p>flow n. 泛滥</p>
<p>focus on 集中于</p>
<p>folk art 民间艺术</p>
<p>for free 免费</p>
<p>forthcoming exhibition 即将进行的展出  [.eksɪ’bɪʃ(ə)n] </p>
<p>foster v. 培养</p>
<p>free of charge 免费</p>
<p>get caught up in 沉迷于</p>
<p>get involved in 参与</p>
<p>get together with 与…相聚</p>
<p>give a break 休息</p>
<p>give sb. freedom in doing sth. 给某人做某事的自由</p>
<p>great and profound 博大精深的</p>
<p>have a version 有愿景</p>
<p>healthful a. 有益健康的</p>
<p>highlight n. 最精彩的部分</p>
<p>hold the ideal 认为</p>
<p>humanity n.  人性</p>
<p>ignore v. 忽略</p>
<p>immortal a. 不朽的   [ɪ’mɔrt(ə)l]</p>
<p>in addition 另外的</p>
<p>in my opinion 在我看来</p>
<p>in recent years 近年来</p>
<p>in the light of 考虑到</p>
<p>independent a. 独立的</p>
<p>indigenous a. 本土的</p>
<p>induce v. 劝诱</p>
<p>industrial waste 工业废料</p>
<p>innovate v. 创新</p>
<p>inspire v. 鼓舞</p>
<p>instruction n. 指导</p>
<p>intolerable a. 无法忍受的    [ɪn’tɑlərəb(ə)l] </p>
<p>irresponsible a. 不负责任的</p>
<p>it is not wise for sb. to do sth 对某人来说，做…是不明智的</p>
<p>key parts of 关键部分</p>
<p>kill time 消磨时间</p>
<p>landfill n. 垃圾场</p>
<p>laziness n. 懒惰</p>
<p>learn about 学习</p>
<p>limited a. 有限的</p>
<p>low-energy  节能’</p>
<p>lure v. 引诱   [lʊr] </p>
<p>major n. 专业</p>
<p>make a mistake 犯错误</p>
<p>make decision 做决定</p>
<p>matter v. 要紧，有关系</p>
<p>memorialize v. 纪念      [mə’mɔ:riəlaɪz] </p>
<p>mess n. 凌乱状态，脏乱状态。混乱的局面，困境。</p>
<p>messy a. 肮脏的</p>
<p>misleading a. 引入歧途的</p>
<p>modern age 当代</p>
<p>modern society 现代社会</p>
<p>negative a. 消极的</p>
<p>sincere n. 诚挚的，真诚的</p>
<p>senator n. 议员</p>
<p>lad n. 男孩，小伙子</p>
<p>equip v. 装备、配备、(智力上，体力上)使有准备</p>
<p>equipment n. 装备、设备</p>
<p>frown v. 皱眉</p>
<p>brown a. 褐色的</p>
<p>fasten v. 扎根，抓牢</p>
<p>stir v. 动，拨动，激动，（某种感情）产生，n. 搅拌，搅动，激动，骚乱。</p>
<p>stir up 激起，挑起</p>
<p>distribution n. 分发，分配，分布</p>
<p>flexible a. 易弯曲的，灵活的。</p>
<p>solution n. 解决； 解决办法。溶液。常于 to 连用，表示解决问题的方法。</p>
<p>panel n. 专门小组，面板，控制板，仪表盘。</p>
<p>ministry n. （政府的）部</p>
<p>supreme a. 最高的，最大的，极度的，最重要的</p>
<p>limb n. 肢，臂，腿，树枝。</p>
<p>climb v. 爬</p>
<p>circumstance n. 情况条件，境遇，经济情况</p>
<p>under on circumstance 无论如何不</p>
<p>in\under the circumstance 在这种情况下，（情况）既然如此</p>
<p>core n. 果实，核心，要点</p>
<p>at the core of 在… 的核心，在…的中心。</p>
<p>debt n. 债务</p>
<p>minus n.  负数，减号，a. 负的 prep. 减去  </p>
<p>depend v. 依赖，取决于，信任</p>
<p>depend on 决定于。</p>
]]></content>
      
        <categories>
            
            <category> Other </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -word </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 文件权限和目录配置]]></title>
      <url>/2017/10/29/LinuxFilePermissionAndConfiguration/</url>
      <content type="html"><![CDATA[<p>Linux一般将文件可以存取访问的身份分为三个类别．分别是 <code>owner</code>,<code>group</code>,<code>others</code>.且３中身份各自有<code>read</code>.<code>write</code>,<code>execute</code>,等权限．</p>
<p>在Linux中文件的权限管理非常重要。</p>
<a id="more"></a>
<h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="1-文件所有者-owner"><a href="#1-文件所有者-owner" class="headerlink" title="1.文件所有者　owner"></a>1.文件所有者　owner</h3><p>Linux是个多用户，多任务的系统，经常会有很多人来使用这台主机来进行操作，为了保护每个人的隐私和每个人喜好的工作环境．就必须确立文件所有者的角色．如果某个文件被某个用户设置成只有文件所有者才能够查看和修改这个文件的内容，他人就无法对这个文件进行查看和修改．　</p>
<h3 id="2-用户组概念-group"><a href="#2-用户组概念-group" class="headerlink" title="2.用户组概念 group"></a>2.用户组概念 group</h3><p>配置文件所属的用户组，最有有用的功能就是，当进行团队开发资源的时候，每个组的成员之间互相对方的数据，而且其他组的成员不能够看到本组自己的文件内容．同时，每个帐号可以有多个用户组的支持，当然了在一个用户组里面也可以设置各自的权限，保留私人的空间．</p>
<h3 id="3-其他人的概念-Others"><a href="#3-其他人的概念-Others" class="headerlink" title="3.其他人的概念　Others"></a>3.其他人的概念　Others</h3><p>只有被拥有权限的用户授权才能够访问相应的文件．</p>
<h3 id="Liunx-用户身份和用户组记录的文件"><a href="#Liunx-用户身份和用户组记录的文件" class="headerlink" title="Liunx 用户身份和用户组记录的文件"></a>Liunx 用户身份和用户组记录的文件</h3><p>在Liunx系统中，默认情况下所有的系统帐号与一般身份用户，还有root的相关信息，都是记录在 /etc/passwd这个文件内，至于个人的密码则是记录在 etc/shadow文件下．Liunx所有的祖名都记录在 /etc/group 内，这个３个文件可以说是Linux中帐号密码和用户组信息的集中地，不要随便删除这三个文件．</p>
<h2 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h2><h3 id="Linux-文件属性．"><a href="#Linux-文件属性．" class="headerlink" title="Linux 文件属性．"></a>Linux 文件属性．</h3><p>要了解Linux的文件属性，一个常用的命令，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls</div></pre></td></tr></table></figure>
<p>ls 是list 的意思，终点显示文件的文件名与相关属性.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al</div></pre></td></tr></table></figure>
<p><code>-al</code>表示列出所有的文件详细的权限和属性（包含隐藏文件，也就是文件名第一个字符为 <code>.</code>的文件．</p>
<p>以root运行上述的命令后，得到的输出类似．</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drwxr-xr-x  3 zero zero 4096 9月  29 18:24 下载</div></pre></td></tr></table></figure>
<p>这是关于下载文件的信息．　</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drwxr-xr-x[文件权限] 3[连接数]　zero[文件所有者]　zero[文件所属用户组] 4096[文件大小] 9月 29 18:24［文件最后被修改时间］　下载[文件名]</div></pre></td></tr></table></figure>
<h4 id="1-第一列表示了这个文件的类型和权限（permission）"><a href="#1-第一列表示了这个文件的类型和权限（permission）" class="headerlink" title="1.第一列表示了这个文件的类型和权限（permission）"></a>1.第一列表示了这个文件的类型和权限（permission）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drwxr-xr-x　　d[文件类型] rwx［文件所有者的权限］r-x[文件所属用户组的权限]　r-x [其他人对此文件的权限．]</div></pre></td></tr></table></figure>
<p>仔细看的话就会发现其中一共有10个字符．</p>
<p>第一个字符表示的是文件的类型．表示这个文件是目录，文件或者是链接文件等．</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>-</td>
<td>文件</td>
</tr>
<tr>
<td>l</td>
<td>表示为连接文件[linkfile]</td>
</tr>
<tr>
<td>b</td>
<td>设备文件里面的可供存储的接口设备．</td>
</tr>
<tr>
<td>c</td>
<td>设备文件内的串行端口设备，例如鼠标，键盘，（一次性存储设备）</td>
</tr>
</tbody>
</table>
<p>接下来的字符，３个一组，分别表示文件所有者（owner）,文件所属用户组(group),其他非本组用户（Others)的权限．[r]表示的可读[read],［w］表示可写[write] ［x］表示可执行[execute].</p>
<p>注意到，rwx所在的位置是不会变的，有权限表示为相应的字符，没有权限用[-]表示．</p>
<blockquote>
<p>需要注意的是，目录和文件的权限意义并不相同，这是因此目录和文件记录的数据内容不同所致．</p>
</blockquote>
<h4 id="2-第二列表示有多少的文件名连接到此节点（i-node）．"><a href="#2-第二列表示有多少的文件名连接到此节点（i-node）．" class="headerlink" title="2.第二列表示有多少的文件名连接到此节点（i-node）．"></a>2.第二列表示有多少的文件名连接到此节点（i-node）．</h4><p>每个文件都会将自己的权限和属性记录到文件系统的 i-node 中，不过我们使用的目录树使用文件名来记录，</p>
<p>因此每个文件名会连接到一个 i-code ,这个属性记录就是有多少个文件名连接到同一个 i-node 号码．</p>
<h4 id="3-第三列表示这个文件或者目录的＂所有者帐号＂"><a href="#3-第三列表示这个文件或者目录的＂所有者帐号＂" class="headerlink" title="3.第三列表示这个文件或者目录的＂所有者帐号＂"></a>3.第三列表示这个文件或者目录的＂所有者帐号＂</h4><h4 id="4-第四列表示这个文件或者目录的＂所属用户组＂"><a href="#4-第四列表示这个文件或者目录的＂所属用户组＂" class="headerlink" title="4.第四列表示这个文件或者目录的＂所属用户组＂"></a>4.第四列表示这个文件或者目录的＂所属用户组＂</h4><h4 id="5-第五列表示这个文件的容量大小-默认单位为-“B”"><a href="#5-第五列表示这个文件的容量大小-默认单位为-“B”" class="headerlink" title="5.第五列表示这个文件的容量大小, 默认单位为　“B”"></a>5.第五列表示这个文件的容量大小, 默认单位为　“B”</h4><h4 id="6-第六列表示这个文件的创建日期或者是最近修改日期．"><a href="#6-第六列表示这个文件的创建日期或者是最近修改日期．" class="headerlink" title="6.第六列表示这个文件的创建日期或者是最近修改日期．"></a>6.第六列表示这个文件的创建日期或者是最近修改日期．</h4><h4 id="7-第七列表示文件名"><a href="#7-第七列表示文件名" class="headerlink" title="7.第七列表示文件名"></a>7.第七列表示文件名</h4><h2 id="Linux文件权限的重要性"><a href="#Linux文件权限的重要性" class="headerlink" title="Linux文件权限的重要性"></a>Linux文件权限的重要性</h2><p>Linux增加了各种文件的权限，最终的用途在于＂数据安全性＂上．</p>
<p>１．系统保护的功能．</p>
<p>２．团队开发或者数据共享的功能．</p>
<p>３．为将权限设置妥当的危害（文件被没有权限的人修改，损害）</p>
<h2 id="Linux文件属性和权限的修改"><a href="#Linux文件属性和权限的修改" class="headerlink" title="Linux文件属性和权限的修改"></a>Linux文件属性和权限的修改</h2><p>用于用户组，所有者，各种身份的权限的修改的命令：</p>
<blockquote>
<p>chgrp : (change group )改变文件所属的用户组</p>
<p>chown: (change owner)改变文件所有者．</p>
<p>chmod : (change model) 改变文件的权限</p>
</blockquote>
<h3 id="chgrp-改变文件所属的用户组"><a href="#chgrp-改变文件所属的用户组" class="headerlink" title="chgrp 改变文件所属的用户组"></a>chgrp 改变文件所属的用户组</h3><blockquote>
<p>注意的是　chgrp　该变的用户组必须是在 /etc/group 文件内存在．</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chgrp [-R]   组名  dirname/filename ...</div><div class="line">[-R]: 并行递归的持续更改，即连同目录下的所有文件目录一起修改．</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls　-l /home/zero/README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw-rw-r-- 1 zero zero 629 10月 17 13:03 README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chgrp lijian /home/zero/README.txt</div></pre></td></tr></table></figure>
<p>查看文件属性：　</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls  -l README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw-rw-r-- 1 zero lijian 629 10月 17 13:03 README.txt</div></pre></td></tr></table></figure>
<h2 id="chown-改变文件的所有者"><a href="#chown-改变文件的所有者" class="headerlink" title="chown 改变文件的所有者"></a>chown 改变文件的所有者</h2><blockquote>
<p>注意的是　chown　该变的用户组必须是在 /etc/group 文件内存在</p>
</blockquote>
<p>语法和范例：　</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown [-R] 帐号名称　文件或者目录</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls　-l /home/zero/README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw-rw-r-- 1 zero lijian 629 10月 17 13:03 README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown lijian README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls  -l README.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw-rw-r-- 1 lijian lijian 629 10月 17 13:03 README.txt</div></pre></td></tr></table></figure>
<p>另一种语法和范例：同时修改用户组和所有者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown [-R] 所有者名:用户组名 文件或者目录</div></pre></td></tr></table></figure>
<h3 id="修改文件权限的意义："><a href="#修改文件权限的意义：" class="headerlink" title="修改文件权限的意义："></a>修改文件权限的意义：</h3><p>最常见的需要修改所有者的例子就是复制文件给你之外的其他人时，使用最简单的<code>cp</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp 源文件　目标文件</div></pre></td></tr></table></figure>
<p>假设要将 test 这个文件复制为 test_copy　文件名，并且要给　lijian　这个人，可以这样做． </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp test test_copy</div><div class="line">ls -al test*</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-rw-rw-r-- 1 zero zero 0 10月 24 23:08 test</div><div class="line">-rw-rw-r-- 1 zero zero 0 10月 24 23:08 test_copy</div></pre></td></tr></table></figure>
<p>cp命令会复制执行者的属性和权限，test_copy 还是归 zero:zero 所有</p>
<p>即使你将这个文件给了 lijian 这个用户，它也无法修改．</p>
<p>这个时候就要修改文件的所有者和用户组．</p>
<h3 id="改变权限-chmod"><a href="#改变权限-chmod" class="headerlink" title="改变权限　chmod"></a>改变权限　chmod</h3><p>权限的设置方法有两种，可以通过数字或者符号的方式进行修改．</p>
<h4 id="数字类型改变文件的权限："><a href="#数字类型改变文件的权限：" class="headerlink" title="数字类型改变文件的权限："></a>数字类型改变文件的权限：</h4><p>我们已经知道，文件的基本权限一共有９个，分别是　owner, group ,others,三种身份的 read write,execute权限．文件的权限字符为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rwxrwxrwx -[owner][group][others]</div></pre></td></tr></table></figure>
<p>每三个权限为一组．</p>
<p>各自的分数对照表如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r : 4        w: 2      r:1</div></pre></td></tr></table></figure>
<p>使用的时候，将每个身份的权限分数进行累加．例如：<code>-rwxr---rx</code>的权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">owner = 4+2+1 = 7</div><div class="line">group = 4 </div><div class="line">others = 2+1 =3</div></pre></td></tr></table></figure>
<p>所以当我们修改权限的时候，该权限的权限数字为 743 .</p>
<p>更改权限的<code>chmod</code>命令的格式是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod [-R] xyz 文件或目录</div></pre></td></tr></table></figure>
<p>-R : 递归迭代命令。使用该命令，目录及其子文件所有的权限都会备更改。</p>
<p>xyz: 文件的权限分数。</p>
<p>例如;将上文的文件的所有属性都启用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chomd -R 777 fileName</div></pre></td></tr></table></figure>
<p>或者你不希望文件被人看到，可以设置成对除了自己外都不可见。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chomd 700 fileName</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的，root用户具有所有的权限，以上设置对root用户没有任何影响。</p>
</blockquote>
<h4 id="符号类型改变文件的权限"><a href="#符号类型改变文件的权限" class="headerlink" title="符号类型改变文件的权限"></a>符号类型改变文件的权限</h4><p>符号类型中，我们使用 <code>u g o</code>分别代表　owner , group ,others 三种用户身份．</p>
<p>｀a｀用来表示所有的身份（all）读写操作的权限可以表示为 <code>r  w  x</code></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>owner</td>
</tr>
<tr>
<td>g</td>
<td>group</td>
</tr>
<tr>
<td>o</td>
<td>others</td>
</tr>
<tr>
<td>a</td>
<td>all [owner,group,others]</td>
</tr>
<tr>
<td>r</td>
<td>read</td>
</tr>
<tr>
<td>w</td>
<td>write</td>
</tr>
<tr>
<td>e</td>
<td>excute</td>
</tr>
<tr>
<td>+</td>
<td>添加权限</td>
</tr>
<tr>
<td>-</td>
<td>去掉权限</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用 <code>=</code>进行权限的设置</p>
</blockquote>
<p>例如，我们想要设置一个文件的权限为 -rwxr-xr-x 时，可以写成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod u=rwx,go=rx fileName</div></pre></td></tr></table></figure>
<p>如果我们不清楚具体的权限，想要让所有人具有可读权限的时候，可以简单设置为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod a+r fileName</div></pre></td></tr></table></figure>
<p>同样去掉可执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod a-x fileName</div></pre></td></tr></table></figure>
<p>当然了，<code>-</code> <code>+</code>也可以引用于单个用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod g+w fileName</div></pre></td></tr></table></figure>
<p>这样就为 group 用户增加来可写入的权限了．</p>
<hr>
<p>以上内容仅仅作为参考用，作者不保证绝对不出现差错，如果想知道更加具体的内容请查看官方的文档．</p>
]]></content>
      
        <categories>
            
            <category> -Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/28/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 源文件的编译命令（javac 命令）]]></title>
      <url>/2017/10/12/Java-javac-grammar/</url>
      <content type="html"><![CDATA[<p>一个编写好的Java源文件<code>.java</code>，要成功运行需要经历 <strong>编译</strong> 、<strong>加载</strong>、<strong>解释</strong> 、<strong>执行</strong> 四个步骤。Java编译程序将源文件编译成JVM可以执行的二进制字节码 <code>.class</code>。程序运行时，JVM将相应的字节码加载到内存中，Java 解释器将字节码翻译为机器代码执行。</p>
<a id="more"></a>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>Java程序运行的第一步是将Java源文件编译成字节码，即<code>.class</code>文件，C/C++编译器在编译源代码的时候，会根据所在平台的硬件信息，通过查表量所有对符号的引用转换为特定的内偏移量，从而保证了程序可以在平台上顺利运行。Java语言设计的初衷就是实现平台无关性（事实上并没有完全实现），做到这一点的一个重要的保证就是保证Java中所有引用信息不能够依赖于特定的硬件平台，因此，Java的编译器在编译时，不会直接将变量和方法的引用编译为数值引用，也不会确定在执行过程中具体的内存布局，而是将引用信息保存在字节码中，待程序在JVM中解释运行时，创建相应的布局，并且通过查表确定变量和方法所在的地址。换句话说就是<strong>字节码保留了做什么的信息，实际JVM来决定具体怎么做。</strong>从而实现了Java的可移植性。</p>
<h2 id="关于javac-exe"><a href="#关于javac-exe" class="headerlink" title="关于javac.exe"></a>关于javac.exe</h2><p>Java的编译程序javac.exe不是真正意义上的可执行程序，而是一个包装器，包含在jdk中，在jre环境下是没有的，它实际上是在运行下面的命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -classpath C:\Pragram Files\Java\JDK\lib\tools.jar com.sun.tools.javac.Main</div></pre></td></tr></table></figure>
<h2 id="Javac-命令的使用"><a href="#Javac-命令的使用" class="headerlink" title="Javac 命令的使用"></a>Javac 命令的使用</h2><p>执行Java编译工作的程序是Java编译器<code>javac.exe</code>，它在Java JDK的<code>bin</code>目录下，Windows下通过cmd执行其路径编译特定的Java文件。要特别注意 使用 javac 编译时提供的源代码名称必须含有<code>.java</code> 后缀。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c:\Pragram Files\Java\JDK\bin\javac Hello.java</div></pre></td></tr></table></figure>
<p>通过设置环境变量后，可以不用给出程序的具体的地址，直接调用<code>javac</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac Hello.java</div></pre></td></tr></table></figure>
<p>生成的字节码文件<code>.class</code>默认和源文件在同一个目录下，可以通过 <code>-d</code>命令指定字节存放的地址。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -d C:\javaProject\bin Hello.java</div></pre></td></tr></table></figure>
<p>生成的 <code>Hello.class</code>文件存放在<code>c:\javaProject\bin</code>目录下bin目录必须实际存在，否则将会报错。</p>
<p>javac 可以隐式的编译一些没有在命令行中提及的源文件（前提是它们都在同一个目录下）使用 <code>-verbos</code>选项跟踪自动编译。在编译源文件时，和源文件所有相关联的类，包括源文件中使用、扩展或者实现的每个类和接口，已及在源文件中没有明确出现，但是通过继承关系提供信息的类与接口的文件都要一并提供。</p>
<p>例如： 如果一个类 Lee 继承自 类 Person ，使用javac 编译时必须一起提供：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -d c:\bin Lee.java Person.java</div></pre></td></tr></table></figure>
<p>当然了，如果这两个文件在同一个目录下，编译Lee.java时就是隐式的自动加载 Person.java。如果不在同一个目录下，就需要指明详细的路径（不推荐，尽量将所有的源文件放在同一个项目文件下,如果关联对象过多，难以管理）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -d C:\bin Lee.java F:\src\Person.java</div></pre></td></tr></table></figure>
<p>可以同时编译多个<code>.java</code>文件，书写时用空格隔开。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac Test1.java Test2.java Test3.java</div></pre></td></tr></table></figure>
<p>为了缩短或者简化javac命令，可以指定一个或者多个每行含有一个文件名的文件。当javac遇到以<code>@</code>开头的参数时，它对那个文件中含有的文件名的操作和命令行的操作是一样的，有利于批量的编译大量文件。同时使得Windows命令行的长度不受限制。</p>
<p>例如，可以在名为sourcefiles的文本文件中列出所有源文件的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello1.java</div><div class="line">Hello2.java</div><div class="line">Hello3.java</div></pre></td></tr></table></figure>
<p>然后在命令行下运行编译器：(主要要带有相应的文件后缀名否则就会因为找不到文件报错。)</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac @sourcefiles.txt</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac Hello1.java Hello2.java Hello3.java</div></pre></td></tr></table></figure>
<h2 id="详细命令"><a href="#详细命令" class="headerlink" title="详细命令"></a>详细命令</h2><p>Javac 的详细命令可以在命令行中输入<code>Javac</code>来查看。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac</div></pre></td></tr></table></figure>
<p>其标准的语法格式如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac [ options ] [sourcefiles][@files]</div></pre></td></tr></table></figure>
<ul>
<li>options: 命令行选项</li>
<li>sourcefiles : 一个或者多个要编译的源文件。例如 ：Hello.java</li>
<li>@files ：一个或者多个源文件的列表文件。如上文中的 <code>sourcefiles.txt</code></li>
</ul>
<h3 id="d-目录"><a href="#d-目录" class="headerlink" title="-d 目录"></a>-d 目录</h3><p>该选项用于生成class目标文件的目录，如果某个类是一个包的组成部分，则javac将会把该类放入反映包名的目录中，必要时创建目录，注意不要破坏class文件反映包名的目录结构，否则在运行时将会找不到文件。如果没有指定-d默认class文件被存放在和源文件相同的目录中。</p>
<p>例如； 如果一个类在包 ：<code>com.elemtype</code>下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.elemtype;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>命令行中输入：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -d C:\workspace\bin Hello.java</div></pre></td></tr></table></figure>
<p>编译后生成的class文件的存放路径将会是：<code>C:\worksapce\bin\com\elemtype\Hello.class</code></p>
<p>需要注意的是，-d 生成的目录并不会被自动的添加到用户类路径中。</p>
<p>JDK编译一个java源文件的时候，搜索类文件的方式和顺序如下：</p>
<ol>
<li><p><strong>Bootstrap classes</strong></p>
<p>Bootstrap默认的是JDK自带的jar或者zip文件，包括 jar\lib下的rt.jar等文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c:\Pragram files\Java\JDK\jre\lib\rt.jar</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Extension classes</strong></p>
<p>默认指的是 <code>jre\lib\ext\</code>下的文件，JDK在搜素完Bootstrap classes后搜索这些文件。</p>
</li>
<li><p><strong>User classes</strong></p>
<p>搜索顺序是当前的目录，环境变量CLASSPATH、-classpath.</p>
</li>
</ol>
<h3 id="classpath-cp"><a href="#classpath-cp" class="headerlink" title="-classpath    -cp"></a>-classpath    -cp</h3><p>-classpath 可以用来设置 User classes -classpath 的路径将会覆盖 CLASSPATH的设置。告知JDK搜索目录名，jar文档，zip文档。使用<code>;</code>进行分割。</p>
<p>例如：当你开发一个公共类并且包装成 一个 elemtype.jar 包，使用这个类的时候，使用 -classpath 告知 编译器 从 elemtype.jar中查找该类，否则将会报错。未找到该类。使用了 -classpath 后将不会再使用CLASSPATH中的类搜索路径，如果CLASSPATH未设置，默认使用 当前目录 <code>.</code>作为类搜索路径。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -classpath C:\lib\elemtype.jar -d classes src\*.java</div></pre></td></tr></table></figure>
<p><code>*.java</code>表示当前目录下的所有java文件。</p>
<p>使用 -classpath的缩写 <code>-cp</code>可以简化命令，上面的命令可以写成：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -cp c:\lib\elemtype.jar -d classes src\*.java</div></pre></td></tr></table></figure>
<p>推荐使用 -classpath 替代CLASSPATH的搜索路径，防止多个项目同时使用CLASSPATH发生潜在的冲突。</p>
<h3 id="sourcepath"><a href="#sourcepath" class="headerlink" title="-sourcepath"></a>-sourcepath</h3><p>编译时，源文件的路径可以用 <code>-sourcepath</code>来设定。具体使用方式和 -classpath 一样。默认情况下和-classpath的路径一样。编译过程中，需要源文件的话会首先在sourcefile 和 @sourcefile 指定的目录下寻找源文件，如果没有找到，会在 <code>-sourcepath</code>的路径下寻找。<code>-sourcepath</code>指定的文件可以是源文件的根目录，jar归档文件，或者是 zip归档文件。</p>
<p>实例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -sourcepath src -d classes src\com\elemtype\Hello.java</div></pre></td></tr></table></figure>
<p>或者使用缩写<code>-sp</code>:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -sp src -d classes src\com\elemtype\Hello.java</div></pre></td></tr></table></figure>
<h3 id="source-和-target"><a href="#source-和-target" class="headerlink" title="source 和 target"></a>source 和 target</h3><p>如果你的电脑上安装了多个JDK,所以包含了多个版本的编译器，和多个版本的JVM.<code>-source</code>命令可以指定使用哪个编译器来进行编译。<code>-target</code>将指定生成和指定JVM兼容的class文件。</p>
<p>例如：想要用 JDK 1.6 版本的编辑器生成兼容 JVM 1.2 的class文件。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -cp lib\Util.zip -sp src -source <span class="number">1.6</span> -target <span class="number">1.2</span> -d classes Hello.java</div></pre></td></tr></table></figure>
<p>想要了解不同版本的特性，请查阅官方文档。</p>
<h2 id="文件目录的组织"><a href="#文件目录的组织" class="headerlink" title="文件目录的组织"></a>文件目录的组织</h2><p>推荐在项目文件夹下建立  src 目录存放源代码，最好创建反映包名的目录结构（需要手动创建目录），建立 bin 目录存放类文件，编译时会为class文件生成（反应包名的目录结构）。</p>
<p>例如 ：Practice项目中有源文件： com.elemtype.Hello.java com.elemtype.uitl.Test.java ,源代码文件目录： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">src </div><div class="line">com</div><div class="line">elemtype</div><div class="line">util  Hello.java</div><div class="line">Test.java</div></pre></td></tr></table></figure>
<p>类文件类似。</p>
<hr>
<p>更多细节请查看官方文档。</p>
<p>^_^</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Javac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 相关语法]]></title>
      <url>/2017/10/12/markdown-notes-basic/</url>
      <content type="html"><![CDATA[<p>用Markdown 编写文章时，常用的一些语法。</p>
<a id="more"></a>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown 支持两种标题的语法，Setext和类Atx格式。</p>
<ul>
<li>类SeText格式采用底线的的形式，采用 <code>=</code> <code>-</code>两种格式表示第一阶和第二阶标题。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">最高阶标题</div><div class="line">=========</div><div class="line">第二阶标题</div><div class="line">---------</div></pre></td></tr></table></figure>
<ul>
<li>类Atx格式则是在首行添加<code>#</code>的格式，表示不同级别的标题大小，一共有6个级别，用一到六个<code>#</code>号表示，可以选择闭合的#在标题文本后面加任意数量的<code>#</code>号。注意<code>#</code>号和文件之间尽量留有一个空格。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section"># 标题一</span></div><div class="line"><span class="section">## 标题二</span></div><div class="line"><span class="section">### 标题三 #</span></div></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用可以使用<code>&gt;</code>符号，可以引用单行，或者是一段的内容，当然了，<code>&gt;</code>也可以嵌套使用。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;单行文本</div><div class="line">&gt;一段文本。</div><div class="line"> 一段文本。</div><div class="line">&gt;&gt;嵌套使用</div></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown支持有序列表和无序列表。</p>
<p>有序列表，<code>*</code> <code>-</code> <code>+</code>加空格加文本格式：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>第一列</div><div class="line"><span class="bullet">- </span>第二列</div><div class="line"><span class="bullet">+ </span>第三列</div></pre></td></tr></table></figure>
<p>无序列表，数字加英文点号加空格后面加文本：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>第一列</div><div class="line"><span class="bullet">2. </span>第二列</div><div class="line"><span class="bullet">3. </span>第三列</div></pre></td></tr></table></figure>
<p><em>需要注意的一点的是，由于数字加点加空格会被认为是一个列表，在上下文中尽量不要出现相同的格式，建议书写时在<code>.</code>前加转移符<code>\</code>.</em></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1\. 文本</div></pre></td></tr></table></figure>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>使用Markdown扩展的反引号标记来替代用缩进表示。如果标记一小块代码，使用<figure class="highlight plain"><figcaption><span>`` ` ``符号，使用多个`` ` ``标记，在反引号和文本之间最好加上空格。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```markdown</div><div class="line">` public static void main(String[] args)&#123;&#125; `</div><div class="line">`` ` ``</div></pre></td></tr></table></figure></p>
<p>大段的代码推荐使用三个反引号的栏式代码块，使代码高亮显示的同时，可以在第一行围栏中指定code的语言类型，可以对相应的关键词高亮显示。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">栏式代码块。</div><div class="line">​</div></pre></td></tr></table></figure>
<p>public static void main(String[] args){<br>  System.out.println(“Hello,workd!”);<br>}<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line">```markdown</div><div class="line">在第一行围栏中指定code语言类型</div><div class="line">​``` Java</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">	System.out.println(&quot;Hello&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>高亮显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	System.out.println(<span class="string">"Hello,world!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 链接的表示主要有两种格式，称为行内式和参照式。</p>
<p>行内式的格式为：<code>[name](link)</code>，如果想要给链接加上title，可以在链接后用双引号包住title的内容，写在链接的末尾。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="string">行内式</span>](<span class="link">http://example.example/"title"</span>)</div><div class="line">eg:</div><div class="line">[<span class="string">百度</span>](<span class="link">http://baidu.com/</span>)</div></pre></td></tr></table></figure>
<p>参考式的格式： <code>[name][id]</code>，并且在文件的任意地方对id进行定义：<code>[id]:http://...</code>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">百度</span>][<span class="symbol">id</span>]</div><div class="line">[<span class="symbol">id</span>]: <span class="link">baidu://baidu.com/</span></div></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown中添加图片的方式和链接基本相同，唯一的区别在于要在图片链接的前面加<code>!</code>。</p>
<p>具体的格式为：<code>![name](link)</code>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">图片1</span>](<span class="link">http://tupian...</span>)</div></pre></td></tr></table></figure>
<p>当然，也可以使用参照式，不作赘述。</p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>在Markdown中使用<code>*</code>将文本包起来表示强调。单个<em>号表示斜体字，双</em>号表示加粗。注意*和要强调的文本之间不能够出现空格。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="emphasis">*斜体*</span></div><div class="line"><span class="strong">**粗体**</span></div></pre></td></tr></table></figure>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>Markdown使用多个(三个及以上)<code>*</code> <code>-</code>或者<code>+</code>表示分隔线。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="emphasis">***</span></div><div class="line">---</div><div class="line">+++</div></pre></td></tr></table></figure>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>Markdown的扩展中还提供了删除线的标记 <code>~</code>,使用两个<code>~</code>将文本内容包起来，可以添加删除线。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~~ 删除线 ~~</div></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown的扩展中支持表格的显示。具体格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">|title1 |title2 | title3 |</div><div class="line">|-------|-------|--------|</div><div class="line">|1      |3      |2       |</div></pre></td></tr></table></figure>
<p>实际效果</p>
<table>
<thead>
<tr>
<th>title1</th>
<th>title2</th>
<th>title3</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>如果想要设置表格内容的对齐方式，可以在分割中添加<code>:</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">居中对齐 </div><div class="line">|:-----:|</div><div class="line">左对齐</div><div class="line">|:------|</div><div class="line">右对齐</div><div class="line">|------:|</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Other </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>Li Jian</p>
<p>大邪僧/日漫宅/</p>
<p>爱生活，爱动漫，爱game.</p>
<p>热爱和coding无关的所有事情。<br>性格怪异，行为疯癫。<br>不学无术，喜欢指手画脚。<br>年龄不小，本事不大。</p>
]]></content>
    </entry>
    
  
</search>
